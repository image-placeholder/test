name: Build WebKit WebView iOS IPA

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build:
    runs-on: macos-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set up Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: 'latest-stable'

      - name: Generate Source Files
        run: |
          # 1. Create AppDelegate.swift with Full Bridge Logic
          cat <<'SWIFTEOF' > AppDelegate.swift
          import UIKit
          import WebKit
          import WKWebViewJavascriptBridge
          import AVFoundation
          import UserNotifications // Added for notifications
          import BackgroundTasks

          @main
          class AppDelegate: UIResponder, UIApplicationDelegate {
              var window: UIWindow?
              var mainViewController: ViewController? 
              
              func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
                  window = UIWindow(frame: UIScreen.main.bounds)
                  let vc = ViewController()
                  window?.rootViewController = vc
                  window?.makeKeyAndVisible()
                  BGTaskScheduler.shared.register(forTaskWithIdentifier: "com.example.webkitapp.refresh", using: nil) { task in
                      self.handleAppRefresh(task: task as! BGAppRefreshTask)
                  }     
                  return true
              }



              func application(_ app: UIApplication,
                               open url: URL,
                               options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {
                  
                  if url.scheme == "mywebkitapp", url.host == "share" {
                      let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                      let noteText = components?.queryItems?.first(where: { $0.name == "text" })?.value ?? ""
                      
                      if let rootVC = mainViewController {
                          DispatchQueue.main.async {
                              rootVC.bridge?.callHandler("onNoteShared", data: ["text": noteText])
                          }
                      }
                      
                      return true
                  }
                  
                  return false
              }

              func handleAppRefresh(task: BGAppRefreshTask) {
                  let request = BGAppRefreshTaskRequest(identifier: "com.example.webkitapp.refresh")
                  request.earliestBeginDate = Date(timeIntervalSinceNow: 3600)
                  try? BGTaskScheduler.shared.submit(request)
          
                  DispatchQueue.main.async {
                      self.mainViewController?.bridge?.call(handlerName: "onBackgroundSync", data: ["time": Date().description]) { response in
                          task.setTaskCompleted(success: true)
                      }
                  }
              }

              func scheduleAppRefresh() {
                  let request = BGAppRefreshTaskRequest(identifier: "com.example.webkitapp.refresh")
                  request.earliestBeginDate = Date(timeIntervalSinceNow: 2 * 60 * 60) // 2 hours
                  try? BGTaskScheduler.shared.submit(request)
              }



              
          }

          class ViewController: UIViewController, WKNavigationDelegate, WKUIDelegate, UNUserNotificationCenterDelegate {
              var webView: WKWebView!
              var bridge: WKWebViewJavascriptBridge?


              // Add this so notifications show up even when app is in foreground
              func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
                  completionHandler([.banner, .sound])
              }



          // MARK: - Bridge Response Helper
          struct BridgeResponse {
              static func success(_ data: Any? = nil, message: String? = nil) -> [String: Any] {
                  var response: [String: Any] = ["success": true]
                  if let data = data {
                      response["data"] = data
                  }
                  if let message = message {
                      response["message"] = message
                  }
                  return response
              }
              
              static func error(_ message: String, code: String? = nil, details: Any? = nil) -> [String: Any] {
                  var response: [String: Any] = [
                      "success": false,
                      "error": message
                  ]
                  if let code = code {
                      response["errorCode"] = code
                  }
                  if let details = details {
                      response["details"] = details
                  }
                  return response
              }
          }
              
              override func loadView() {
                  let webConfiguration = WKWebViewConfiguration()

                  // Inject JavaScript into the WKWebView before loading content
                  let jsSetup = """
                  function setupWKWebViewJavascriptBridge(callback) {
                      if (window.WKWebViewJavascriptBridge) { return callback(WKWebViewJavascriptBridge); }
                      if (window.WKWVJBCallbacks) { return window.WKWVJBCallbacks.push(callback); }
                      window.WKWVJBCallbacks = [callback];
                      window.webkit.messageHandlers.iOS_Native_InjectJavascript.postMessage(null);
                  }

                  window.setupWKWebViewJavascriptBridge = setupWKWebViewJavascriptBridge;
                  """

                  let userScript = WKUserScript(source: jsSetup, injectionTime: .atDocumentStart, forMainFrameOnly: false)
                  webConfiguration.userContentController.addUserScript(userScript)
                  webConfiguration.applicationNameForUserAgent = "MyIOSApp"

                  webView = WKWebView(frame: .zero, configuration: webConfiguration)
                  webView.navigationDelegate = self
                  webView.uiDelegate = self
                  view = webView
              }

              override func viewDidLoad() {
                  super.viewDidLoad()
                  if #available(iOS 16.4, *) {
                  // This is FALSE by default in Release builds, but explicitly setting it is safer
                  webView.isInspectable = false 
                  }
                  UNUserNotificationCenter.current().delegate = self
                  // Instantiate the bridge after the WebView is loaded
                  self.bridge = WKWebViewJavascriptBridge(webView: webView)

                  // Register Native Handler for JS to call
                  self.bridge?.register(handlerName: "testiOSCallback") { (parameters, callback) in
                      print("testiOSCallback called with: \(String(describing: parameters))")
                      callback?("Response from testiOSCallback")
                  }


                self.bridge?.register(handlerName: "scheduleBackgroundSync") { (parameters, callback) in
                    let hours = (parameters as? [String: Any])?["hours"] as? Double ?? 2.0
                    
                    let request = BGAppRefreshTaskRequest(identifier: "com.example.webkitapp.refresh")
                    request.earliestBeginDate = Date(timeIntervalSinceNow: hours * 3600)
                    
                    do {
                        try BGTaskScheduler.shared.submit(request)
                        callback?("Successfully scheduled for \(hours) hours from now")
                    } catch {
                        callback?("Error: \(error.localizedDescription)")
                    }
                }

                  // Register Native Handler for JS to call
                  self.bridge?.register(handlerName: "showNotification") { [weak self] (parameters, callback) in
                      print("testiOSCallback called with: \(String(describing: parameters))")
                      
                      // Switch to the main thread to present the UI safely
                      DispatchQueue.main.async {
                          // Guard against self being nil
                          guard let strongSelf = self else { return }
                          
                          // Ensure we aren't already presenting something (prevents "balanced transitions" crash)
                          if strongSelf.presentedViewController != nil {
                              print("An alert is already being presented.")
                              return
                          }
                  
                          let jsData = parameters as? [String: Any]
                          let messageBody = jsData?["message"] as? String ?? "Notification from WebKit"
                          
                          let alert = UIAlertController(
                              title: "iOS Notification",
                              message: messageBody,
                              preferredStyle: .alert
                          )
                          
                          alert.addAction(UIAlertAction(title: "OK", style: .default, handler: nil))
                          
                          // Present the alert safely
                          strongSelf.present(alert, animated: true, completion: nil)
                      }
                      
                      callback?("Response from testiOSCallback")
                  }



                  self.bridge?.register(handlerName: "vibrate") { (parameters, _) in
                      DispatchQueue.main.async {
                          let generator = UIImpactFeedbackGenerator(style: .medium)
                          generator.impactOccurred()
                      }
                  }

                self.bridge?.register(handlerName: "getDeviceInfo") { (_, callback) in
                    UIDevice.current.isBatteryMonitoringEnabled = true
                    let info = [
                        "model": UIDevice.current.model,
                        "battery": "\(UIDevice.current.batteryLevel * 100)%",
                        "system": UIDevice.current.systemVersion
                    ]
                    callback?(info)
                }

                   self.bridge?.register(handlerName: "setBrightness") { (parameters, _) in
                    if let level = (parameters as? [String: Any])?["level"] as? CGFloat {
                        DispatchQueue.main.async { UIScreen.main.brightness = level }
                    }
                }             


                   self.bridge?.register(handlerName: "nativeShare") { [weak self] (parameters, _) in
                    guard let text = (parameters as? [String: Any])?["text"] as? String else { return }
                    DispatchQueue.main.async {
                        let ac = UIActivityViewController(activityItems: [text], applicationActivities: nil)
                        self?.present(ac, animated: true)
                    }
                }             

                self.bridge?.register(handlerName: "saveSecure") { (parameters, callback) in
                    let data = parameters as? [String: Any]
                    let key = data?["key"] as? String ?? "default"
                    let value = data?["value"] as? String ?? ""
                
                    let query: [String: Any] = [
                        kSecClass as String: kSecClassGenericPassword,
                        kSecAttrAccount as String: key,
                        kSecValueData as String: value.data(using: .utf8)!
                    ]
                    SecItemDelete(query as CFDictionary) // Clear existing
                    let status = SecItemAdd(query as CFDictionary, nil)
                    callback?(status == errSecSuccess ? "Success" : "Error")
                }


                  self.bridge?.register(handlerName: "clearCookies") { (_, callback) in
                    DispatchQueue.main.async {
                        let dataStore = WKWebsiteDataStore.default()
                        let types = WKWebsiteDataStore.allWebsiteDataTypes()
                        let dateFrom = Date(timeIntervalSince1970: 0)
                
                        dataStore.removeData(ofTypes: types, modifiedSince: dateFrom) {
                            callback?("Cookies Cleared")
                        }
                    }
                }              


                  
              self.bridge?.register(handlerName: "toggleFlashlight") { (parameters, callback) in
                  // 1. Try to get the hardware
                  guard let device = AVCaptureDevice.default(for: .video), device.hasTorch else {
                      callback?("Error: Hardware not available") // Resolve even if hardware fails
                      return 
                  }
                  
                  let isOn = (parameters as? [String: Any])?["on"] as? Bool ?? false
                  
                  do {
                      try device.lockForConfiguration()
                      device.torchMode = isOn ? .on : .off
                      device.unlockForConfiguration()
                      
                      // 2. Crucial: Tell JS we are done!
                      callback?("Flashlight set to \(isOn)") 
                  } catch {
                      callback?("Error: Could not lock hardware")
                  }
              }


              self.bridge?.register(handlerName: "showLocalPush") { (parameters, callback) in
                  let center = UNUserNotificationCenter.current()
                  
                  // 1. Request Permission first
                  center.requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in
                      if granted {
                          let data = parameters as? [String: Any]
                          let title = data?["title"] as? String ?? "New Message"
                          let body = data?["body"] as? String ?? "You have a new notification."
                          
                          // 2. Create Content
                          let content = UNMutableNotificationContent()
                          content.title = title
                          content.body = body
                          content.sound = .default
                          
                          // 3. Create Trigger (Show after 1 second)
                          let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)
                          
                          // 4. Create Request
                          let request = UNNotificationRequest(
                              identifier: UUID().uuidString, 
                              content: content, 
                              trigger: trigger
                          )
                          
                          // 5. Schedule
                          center.add(request) { (error) in
                              if let error = error {
                                  callback?("Error: \(error.localizedDescription)")
                              } else {
                                  callback?("Notification Scheduled")
                              }
                          }
                      } else {
                          callback?("Permission Denied")
                      }
                  }
              }



             self.bridge?.register(handlerName: "openURL") { (parameters, _) in
                  guard let urlString = (parameters as? [String: Any])?["url"] as? String,
                        let url = URL(string: urlString) else { return }
                  DispatchQueue.main.async {
                      if UIApplication.shared.canOpenURL(url) {
                          UIApplication.shared.open(url, options: [:], completionHandler: nil)
                      } else {
                          // Handle error if app is not installed (e.g., show an alert or handle fallback)
                          print("App not installed or invalid URL")
                      }
                  }
              }


           self.bridge?.register(handlerName: "requestNotificationPermission") { (parameters, callback) in
                // 1. Request Notification Permission
                let center = UNUserNotificationCenter.current()
                
                center.requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in
                    if let error = error {
                        // If error occurs during permission request, callback with error message
                        callback?(false)
                    } else if granted {
                        // If permission is granted, callback success
                        callback?(granted)
                    } else {
                        // If permission is denied, callback denial message
                        callback?(false)
                    }
                }
            }


              
              self.bridge?.register(handlerName: "lockOrientation") { (parameters, _) in
                  if let orientation = (parameters as? [String: Any])?["orientation"] as? String {
                      DispatchQueue.main.async {
                          if orientation == "portrait" {
                              UIDevice.current.setValue(UIInterfaceOrientation.portrait.rawValue, forKey: "orientation")
                          } else if orientation == "landscape" {
                              UIDevice.current.setValue(UIInterfaceOrientation.landscapeLeft.rawValue, forKey: "orientation")
                          }
                      }
                  }
              }
              
              self.bridge?.register(handlerName: "getBatteryInfo") { (_, callback) in
                  UIDevice.current.isBatteryMonitoringEnabled = true
                  let batteryLevel = UIDevice.current.batteryLevel * 100
                  let batteryState: String
                  switch UIDevice.current.batteryState {
                  case .charging: batteryState = "Charging"
                  case .full: batteryState = "Full"
                  case .unplugged: batteryState = "Unplugged"
                  default: batteryState = "Unknown"
                  }
                  callback?(["batteryLevel": "\(batteryLevel)%", "batteryState": batteryState])
              }
              
              self.bridge?.register(handlerName: "openMaps") { (parameters, _) in
                  guard let address = (parameters as? [String: Any])?["address"] as? String else { return }
                  DispatchQueue.main.async {
                      let urlString = "https://maps.apple.com/?q=\(address)"
                      if let url = URL(string: urlString) {
                          UIApplication.shared.open(url, options: [:], completionHandler: nil)
                      }
                  }
              }


              // Helper to check status
                func isUserPremium() -> Bool {
                    return UserDefaults.standard.bool(forKey: "isPremiumUser")
                }
                
                // 1. Function to 'unlock' (simulating a purchase)
                self.bridge?.register(handlerName: "unlockPremium") { (_, callback) in
                    UserDefaults.standard.set(true, forKey: "isPremiumUser")
                    callback?("Success: Premium Unlocked")
                }
                
                // 2. The Restricted Function
                self.bridge?.register(handlerName: "premiumFeature") { [weak self] (parameters, callback) in
                    guard isUserPremium() else {
                        callback?("Error: This is a paid feature. Please upgrade.")
                        return
                    }
                    
                    // If they ARE premium, run the code
                    DispatchQueue.main.async {
                        let alert = UIAlertController(title: "Premium Access", message: "Executing paid function...", preferredStyle: .alert)
                        alert.addAction(UIAlertAction(title: "OK", style: .default))
                        self?.present(alert, animated: true)
                    }
                    callback?("Feature Executed")
                }


                self.bridge?.register(handlerName: "premiumFeature2") { [weak self] (parameters, callback) in
                    // 1. Extract User ID from the JS call
                    guard let data = parameters as? [String: Any],
                          let userId = data["userId"] as? String else {
                        callback?("Error: Missing User ID")
                        return
                    }
                
                    // 2. Define your Server URL
                    let url = URL(string: "https://your-api.com/check-subscription?uid=\(userId)")!
                    
                    // 3. Perform a Native Network Request
                    let task = URLSession.shared.dataTask(with: url) { (data, response, error) in
                        if let data = data, let responseString = String(data: data, encoding: .utf8) {
                            
                            // 4. Check if Server returned "Yes" (or 1, or a valid token)
                            if responseString.contains("Yes") {
                                DispatchQueue.main.async {
                                    // --- PROTECTED NATIVE LOGIC START ---
                                    let alert = UIAlertController(title: "Verified", message: "Premium access granted!", preferredStyle: .alert)
                                    alert.addAction(UIAlertAction(title: "OK", style: .default))
                                    self?.present(alert, animated: true)
                                    // --- PROTECTED NATIVE LOGIC END ---
                                    
                                    callback?("Access Granted")
                                }
                            } else {
                                callback?("Error: Subscription inactive")
                            }
                        } else {
                            callback?("Error: Server unreachable")
                        }
                    }
                    task.resume()
                }

                
                  let url = URL(string: "https://snippets.marketingpipeliners.com")!
                  webView.load(URLRequest(url: url))
              }

              func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
                  // Call JS Handler from Native once page finishes loading
                  self.bridge?.call(handlerName: "testJavascriptHandler", data: ["foo": "before ready"], callback: { response in
                      print("JS responded: \(String(describing: response))")
                  })

                  // Visual confirmation
                  webView.evaluateJavaScript("alert('Bridge Initialized');")
                  webView.evaluateJavaScript("window._SETTINGS.APPTYPE = 'ios';")
              }

              // Handle JavaScript Alerts (alert, confirm, prompt)
              func webView(_ webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping () -> Void) {
                  let alert = UIAlertController(title: "JS Alert", message: message, preferredStyle: .alert)
                  alert.addAction(UIAlertAction(title: "OK", style: .default) { _ in completionHandler() })
                  present(alert, animated: true)
              }
          
              func webView(_ webView: WKWebView, runJavaScriptConfirmPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (Bool) -> Void) {
                  let confirmAlert = UIAlertController(title: "JS Confirm", message: message, preferredStyle: .alert)
                  confirmAlert.addAction(UIAlertAction(title: "Cancel", style: .cancel) { _ in
                      completionHandler(false) // User pressed Cancel
                  })
                  confirmAlert.addAction(UIAlertAction(title: "OK", style: .default) { _ in
                      completionHandler(true) // User pressed OK
                  })
                  present(confirmAlert, animated: true)
              }
          
              func webView(_ webView: WKWebView, runJavaScriptTextInputPanelWithPrompt prompt: String, defaultText: String?, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (String?) -> Void) {
                  let promptAlert = UIAlertController(title: "JS Prompt", message: prompt, preferredStyle: .alert)
                  
                  // Add a text field for the user to input
                  promptAlert.addTextField { textField in
                      textField.text = defaultText
                  }
          
                  promptAlert.addAction(UIAlertAction(title: "Cancel", style: .cancel) { _ in
                      completionHandler(nil) // User pressed Cancel
                  })
                  promptAlert.addAction(UIAlertAction(title: "OK", style: .default) { _ in
                      let text = promptAlert.textFields?.first?.text
                      completionHandler(text) // User entered some text
                  })
                  
                  present(promptAlert, animated: true)
              }
          }
          EOF

          # 2. Create Info.plist for the project
          cat <<EOF > Info.plist
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>CFBundleExecutable</key>
              <string>WebKitApp</string>
              <key>CFBundleIdentifier</key>
              <string>com.example.webkitapp</string>
              <key>CFBundleName</key>
              <string>WebKitApp</string>
              <key>CFBundlePackageType</key>
              <string>APPL</string>
              <key>CFBundleShortVersionString</key>
              <string>1.0</string>
              <key>CFBundleVersion</key>
              <string>1</string>
              <key>LSRequiresIPhoneOS</key>
              <true/>
              <key>UILaunchScreen</key>
              <dict/>
              <key>NSAppTransportSecurity</key>
              <dict>
                  <key>NSAllowsArbitraryLoads</key>
                  <true/>
              </dict>
              <key>UIBackgroundModes</key>
              <array>
                  <string>fetch</string>
                  <string>processing</string>
              </array>
              <key>BGTaskSchedulerPermittedIdentifiers</key>
              <array>
                  <string>com.example.webkitapp.refresh</string>
              </array>
              <key>CFBundleURLTypes</key>
              <array>
                  <dict>
                      <key>CFBundleURLSchemes</key>
                      <array>
                          <string>mywebkitapp</string>
                      </array>
                  </dict>
              </array>
          </dict>
          </plist>
          EOF

      - name: Create Xcode Project
        run: |
          gem install xcodeproj
          ruby -e "
          require 'xcodeproj'
          project = Xcodeproj::Project.new('WebKitApp.xcodeproj')
          
          # 1. Create Main App Target
          target = project.new_target(:application, 'WebKitApp', :ios, '15.0')
          app_delegate = project.new_file('AppDelegate.swift')
          target.add_file_references([app_delegate])

          # 2. Create Share Extension Target
          share_target = project.new_target(:app_extension, 'ShareExtension', :ios, '15.0')
          share_vc = project.new_file('ShareViewController.swift')
          share_plist = project.new_file('Share-Info.plist')
          share_target.add_file_references([share_vc])

          # 3. Setup Build Settings for Main App
          target.build_configurations.each do |config|
            config.build_settings['INFOPLIST_FILE'] = 'Info.plist'
            config.build_settings['PRODUCT_BUNDLE_IDENTIFIER'] = 'com.example.webkitapp'
            config.build_settings['SWIFT_VERSION'] = '5.0'
            config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '15.0'
          end

          # 4. Setup Build Settings for Share Extension
          share_target.build_configurations.each do |config|
            config.build_settings['INFOPLIST_FILE'] = 'Share-Info.plist'
            config.build_settings['PRODUCT_BUNDLE_IDENTIFIER'] = 'com.example.webkitapp.ShareExtension'
            config.build_settings['SWIFT_VERSION'] = '5.0'
            config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '15.0'
            config.build_settings['SKIP_INSTALL'] = 'YES'
          end

          # 5. Add Extension as a dependency of the Main App
          target.add_dependency(share_target)
          
          # Create copy files build phase to embed the extension in the app bundle
          copy_phase = target.new_copy_files_build_phase('Embed App Extensions')
          copy_phase.dst_subfolder_spec = '13' # 13 is the code for 'PlugIns' folder
          copy_phase.add_file_reference(share_target.product_reference)

          project.recreate_user_schemes
          project.save
          "

      - name: Create and Install Pods
        run: |
          cat <<'PODEOF' > Podfile
          platform :ios, '15.0'
          use_frameworks!
          target 'WebKitApp' do
            pod 'WKWebViewJavascriptBridge', '~> 1.2.0'
          end

          post_install do |installer|
            installer.pods_project.targets.each do |target|
              target.build_configurations.each do |config|
                config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '15.0'
              end
            end
          end
          PODEOF
          pod install

      - name: Create and Install Pods
        run: |
          cat <<EOF > Podfile
          platform :ios, '15.0'
          use_frameworks!
          target 'WebKitApp' do
            pod 'WKWebViewJavascriptBridge', '~> 1.2.0'
          end

          post_install do |installer|
            installer.pods_project.targets.each do |target|
              target.build_configurations.each do |config|
                config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '15.0'
              end
            end
          end
          EOF
          pod install

      - name: Build Archive (Unsigned)
        run: |
          xcodebuild archive \
            -workspace WebKitApp.xcworkspace \
            -scheme WebKitApp \
            -configuration Release \
            -archivePath ./build/WebKitApp.xcarchive \
            CODE_SIGNING_ALLOWED=NO \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGN_IDENTITY="" \
            AD_HOC_CODE_SIGNING_ALLOWED=YES

      - name: Package IPA
        run: |
          mkdir -p Payload
          cp -r ./build/WebKitApp.xcarchive/Products/Applications/*.app ./Payload/
          zip -r WebKitApp-Unsigned.ipa Payload

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: WebKit-WebView-IPA
          path: WebKitApp-Unsigned.ipa
