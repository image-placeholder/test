name: Build WebKit WebView iOS IPA

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build:
    runs-on: macos-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set up Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: 'latest-stable'

      - name: Generate Source Files
        run: |
          # 1. Create AppDelegate.swift with Full Bridge Logic
          cat <<EOF > AppDelegate.swift
          import UIKit
          import WebKit
          import WKWebViewJavascriptBridge
          import AVFoundation
          import UserNotifications // Added for notifications
          import BackgroundTasks

          @main
          class AppDelegate: UIResponder, UIApplicationDelegate {
              var window: UIWindow?
              var mainViewController: ViewController? 
              
              func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
                  window = UIWindow(frame: UIScreen.main.bounds)
                  let vc = ViewController()
                  window?.rootViewController = vc
                  window?.makeKeyAndVisible()
              
                  // Register background task
                  BGTaskScheduler.shared.register(forTaskWithIdentifier: "com.example.webkitapp.refresh", using: nil) { task in
                      self.handleAppRefresh(task: task as! BGAppRefreshTask)
                  }
              
                  // Check if the app was opened via a custom URL scheme (e.g., mywebkitapp://share)
                  if let url = launchOptions?[.url] as? URL {
                      // Check if the URL is from the share extension
                      if url.scheme == "mywebkitapp" && url.host == "share" {
                          let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                          let noteText = components?.queryItems?.first(where: { $0.name == "text" })?.value
                          
                          // Pass the note text to your JS Bridge
                          DispatchQueue.main.async {
                              self.mainViewController?.bridge?.callHandler("onNoteShared", data: ["text": noteText ?? ""])
                          }
                      }
                  }
              
                  return true
              }



              func handleAppRefresh(task: BGAppRefreshTask) {
                  let request = BGAppRefreshTaskRequest(identifier: "com.example.webkitapp.refresh")
                  request.earliestBeginDate = Date(timeIntervalSinceNow: 3600)
                  try? BGTaskScheduler.shared.submit(request)
          
                  DispatchQueue.main.async {
                      self.mainViewController?.bridge?.call(handlerName: "onBackgroundSync", data: ["time": Date().description]) { response in
                          task.setTaskCompleted(success: true)
                      }
                  }
              }

              func scheduleAppRefresh() {
                  let request = BGAppRefreshTaskRequest(identifier: "com.example.webkitapp.refresh")
                  request.earliestBeginDate = Date(timeIntervalSinceNow: 2 * 60 * 60) // 2 hours
                  try? BGTaskScheduler.shared.submit(request)
              }
              
          }

          class ViewController: UIViewController, WKNavigationDelegate, WKUIDelegate, UNUserNotificationCenterDelegate {
              var webView: WKWebView!
              var bridge: WKWebViewJavascriptBridge?


              // Add this so notifications show up even when app is in foreground
              func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
                  completionHandler([.banner, .sound])
              }



          // MARK: - Bridge Response Helper
          struct BridgeResponse {
              static func success(_ data: Any? = nil, message: String? = nil) -> [String: Any] {
                  var response: [String: Any] = ["success": true]
                  if let data = data {
                      response["data"] = data
                  }
                  if let message = message {
                      response["message"] = message
                  }
                  return response
              }
              
              static func error(_ message: String, code: String? = nil, details: Any? = nil) -> [String: Any] {
                  var response: [String: Any] = [
                      "success": false,
                      "error": message
                  ]
                  if let code = code {
                      response["errorCode"] = code
                  }
                  if let details = details {
                      response["details"] = details
                  }
                  return response
              }
          }
              
              override func loadView() {
                  let webConfiguration = WKWebViewConfiguration()

                  // Inject JavaScript into the WKWebView before loading content
                  let jsSetup = """
                  function setupWKWebViewJavascriptBridge(callback) {
                      if (window.WKWebViewJavascriptBridge) { return callback(WKWebViewJavascriptBridge); }
                      if (window.WKWVJBCallbacks) { return window.WKWVJBCallbacks.push(callback); }
                      window.WKWVJBCallbacks = [callback];
                      window.webkit.messageHandlers.iOS_Native_InjectJavascript.postMessage(null);
                  }

                  window.setupWKWebViewJavascriptBridge = setupWKWebViewJavascriptBridge;
                  """

                  let userScript = WKUserScript(source: jsSetup, injectionTime: .atDocumentStart, forMainFrameOnly: false)
                  webConfiguration.userContentController.addUserScript(userScript)
                  webConfiguration.applicationNameForUserAgent = "MyIOSApp"

                  webView = WKWebView(frame: .zero, configuration: webConfiguration)
                  webView.navigationDelegate = self
                  webView.uiDelegate = self
                  view = webView
              }

              override func viewDidLoad() {
                  super.viewDidLoad()
                  if #available(iOS 16.4, *) {
                  // This is FALSE by default in Release builds, but explicitly setting it is safer
                  webView.isInspectable = false 
                  }
                  UNUserNotificationCenter.current().delegate = self
                  // Instantiate the bridge after the WebView is loaded
                  self.bridge = WKWebViewJavascriptBridge(webView: webView)

                  // Register Native Handler for JS to call
                  self.bridge?.register(handlerName: "testiOSCallback") { (parameters, callback) in
                      print("testiOSCallback called with: \(String(describing: parameters))")
                      callback?("Response from testiOSCallback")
                  }


                self.bridge?.register(handlerName: "scheduleBackgroundSync") { (parameters, callback) in
                    let hours = (parameters as? [String: Any])?["hours"] as? Double ?? 2.0
                    
                    let request = BGAppRefreshTaskRequest(identifier: "com.example.webkitapp.refresh")
                    request.earliestBeginDate = Date(timeIntervalSinceNow: hours * 3600)
                    
                    do {
                        try BGTaskScheduler.shared.submit(request)
                        callback?("Successfully scheduled for \(hours) hours from now")
                    } catch {
                        callback?("Error: \(error.localizedDescription)")
                    }
                }

                  // Register Native Handler for JS to call
                  self.bridge?.register(handlerName: "showNotification") { [weak self] (parameters, callback) in
                      print("testiOSCallback called with: \(String(describing: parameters))")
                      
                      // Switch to the main thread to present the UI safely
                      DispatchQueue.main.async {
                          // Guard against self being nil
                          guard let strongSelf = self else { return }
                          
                          // Ensure we aren't already presenting something (prevents "balanced transitions" crash)
                          if strongSelf.presentedViewController != nil {
                              print("An alert is already being presented.")
                              return
                          }
                  
                          let jsData = parameters as? [String: Any]
                          let messageBody = jsData?["message"] as? String ?? "Notification from WebKit"
                          
                          let alert = UIAlertController(
                              title: "iOS Notification",
                              message: messageBody,
                              preferredStyle: .alert
                          )
                          
                          alert.addAction(UIAlertAction(title: "OK", style: .default, handler: nil))
                          
                          // Present the alert safely
                          strongSelf.present(alert, animated: true, completion: nil)
                      }
                      
                      callback?("Response from testiOSCallback")
                  }



                  self.bridge?.register(handlerName: "vibrate") { (parameters, _) in
                      DispatchQueue.main.async {
                          let generator = UIImpactFeedbackGenerator(style: .medium)
                          generator.impactOccurred()
                      }
                  }

                self.bridge?.register(handlerName: "getDeviceInfo") { (_, callback) in
                    UIDevice.current.isBatteryMonitoringEnabled = true
                    let info = [
                        "model": UIDevice.current.model,
                        "battery": "\(UIDevice.current.batteryLevel * 100)%",
                        "system": UIDevice.current.systemVersion
                    ]
                    callback?(info)
                }

                   self.bridge?.register(handlerName: "setBrightness") { (parameters, _) in
                    if let level = (parameters as? [String: Any])?["level"] as? CGFloat {
                        DispatchQueue.main.async { UIScreen.main.brightness = level }
                    }
                }             


                   self.bridge?.register(handlerName: "nativeShare") { [weak self] (parameters, _) in
                    guard let text = (parameters as? [String: Any])?["text"] as? String else { return }
                    DispatchQueue.main.async {
                        let ac = UIActivityViewController(activityItems: [text], applicationActivities: nil)
                        self?.present(ac, animated: true)
                    }
                }             

                self.bridge?.register(handlerName: "saveSecure") { (parameters, callback) in
                    let data = parameters as? [String: Any]
                    let key = data?["key"] as? String ?? "default"
                    let value = data?["value"] as? String ?? ""
                
                    let query: [String: Any] = [
                        kSecClass as String: kSecClassGenericPassword,
                        kSecAttrAccount as String: key,
                        kSecValueData as String: value.data(using: .utf8)!
                    ]
                    SecItemDelete(query as CFDictionary) // Clear existing
                    let status = SecItemAdd(query as CFDictionary, nil)
                    callback?(status == errSecSuccess ? "Success" : "Error")
                }


                  self.bridge?.register(handlerName: "clearCookies") { (_, callback) in
                    DispatchQueue.main.async {
                        let dataStore = WKWebsiteDataStore.default()
                        let types = WKWebsiteDataStore.allWebsiteDataTypes()
                        let dateFrom = Date(timeIntervalSince1970: 0)
                
                        dataStore.removeData(ofTypes: types, modifiedSince: dateFrom) {
                            callback?("Cookies Cleared")
                        }
                    }
                }              


                  
              self.bridge?.register(handlerName: "toggleFlashlight") { (parameters, callback) in
                  // 1. Try to get the hardware
                  guard let device = AVCaptureDevice.default(for: .video), device.hasTorch else {
                      callback?("Error: Hardware not available") // Resolve even if hardware fails
                      return 
                  }
                  
                  let isOn = (parameters as? [String: Any])?["on"] as? Bool ?? false
                  
                  do {
                      try device.lockForConfiguration()
                      device.torchMode = isOn ? .on : .off
                      device.unlockForConfiguration()
                      
                      // 2. Crucial: Tell JS we are done!
                      callback?("Flashlight set to \(isOn)") 
                  } catch {
                      callback?("Error: Could not lock hardware")
                  }
              }


              self.bridge?.register(handlerName: "showLocalPush") { (parameters, callback) in
                  let center = UNUserNotificationCenter.current()
                  
                  // 1. Request Permission first
                  center.requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in
                      if granted {
                          let data = parameters as? [String: Any]
                          let title = data?["title"] as? String ?? "New Message"
                          let body = data?["body"] as? String ?? "You have a new notification."
                          
                          // 2. Create Content
                          let content = UNMutableNotificationContent()
                          content.title = title
                          content.body = body
                          content.sound = .default
                          
                          // 3. Create Trigger (Show after 1 second)
                          let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)
                          
                          // 4. Create Request
                          let request = UNNotificationRequest(
                              identifier: UUID().uuidString, 
                              content: content, 
                              trigger: trigger
                          )
                          
                          // 5. Schedule
                          center.add(request) { (error) in
                              if let error = error {
                                  callback?("Error: \(error.localizedDescription)")
                              } else {
                                  callback?("Notification Scheduled")
                              }
                          }
                      } else {
                          callback?("Permission Denied")
                      }
                  }
              }



             self.bridge?.register(handlerName: "openURL") { (parameters, _) in
                  guard let urlString = (parameters as? [String: Any])?["url"] as? String,
                        let url = URL(string: urlString) else { return }
                  DispatchQueue.main.async {
                      if UIApplication.shared.canOpenURL(url) {
                          UIApplication.shared.open(url, options: [:], completionHandler: nil)
                      } else {
                          // Handle error if app is not installed (e.g., show an alert or handle fallback)
                          print("App not installed or invalid URL")
                      }
                  }
              }


           self.bridge?.register(handlerName: "requestNotificationPermission") { (parameters, callback) in
                // 1. Request Notification Permission
                let center = UNUserNotificationCenter.current()
                
                center.requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in
                    if let error = error {
                        // If error occurs during permission request, callback with error message
                        callback?(false)
                    } else if granted {
                        // If permission is granted, callback success
                        callback?(granted)
                    } else {
                        // If permission is denied, callback denial message
                        callback?(false)
                    }
                }
            }


              
              self.bridge?.register(handlerName: "lockOrientation") { (parameters, _) in
                  if let orientation = (parameters as? [String: Any])?["orientation"] as? String {
                      DispatchQueue.main.async {
                          if orientation == "portrait" {
                              UIDevice.current.setValue(UIInterfaceOrientation.portrait.rawValue, forKey: "orientation")
                          } else if orientation == "landscape" {
                              UIDevice.current.setValue(UIInterfaceOrientation.landscapeLeft.rawValue, forKey: "orientation")
                          }
                      }
                  }
              }
              
              self.bridge?.register(handlerName: "getBatteryInfo") { (_, callback) in
                  UIDevice.current.isBatteryMonitoringEnabled = true
                  let batteryLevel = UIDevice.current.batteryLevel * 100
                  let batteryState: String
                  switch UIDevice.current.batteryState {
                  case .charging: batteryState = "Charging"
                  case .full: batteryState = "Full"
                  case .unplugged: batteryState = "Unplugged"
                  default: batteryState = "Unknown"
                  }
                  callback?(["batteryLevel": "\(batteryLevel)%", "batteryState": batteryState])
              }
              
              self.bridge?.register(handlerName: "openMaps") { (parameters, _) in
                  guard let address = (parameters as? [String: Any])?["address"] as? String else { return }
                  DispatchQueue.main.async {
                      let urlString = "https://maps.apple.com/?q=\(address)"
                      if let url = URL(string: urlString) {
                          UIApplication.shared.open(url, options: [:], completionHandler: nil)
                      }
                  }
              }


              // Helper to check status
                func isUserPremium() -> Bool {
                    return UserDefaults.standard.bool(forKey: "isPremiumUser")
                }
                
                // 1. Function to 'unlock' (simulating a purchase)
                self.bridge?.register(handlerName: "unlockPremium") { (_, callback) in
                    UserDefaults.standard.set(true, forKey: "isPremiumUser")
                    callback?("Success: Premium Unlocked")
                }
                
                // 2. The Restricted Function
                self.bridge?.register(handlerName: "premiumFeature") { [weak self] (parameters, callback) in
                    guard isUserPremium() else {
                        callback?("Error: This is a paid feature. Please upgrade.")
                        return
                    }
                    
                    // If they ARE premium, run the code
                    DispatchQueue.main.async {
                        let alert = UIAlertController(title: "Premium Access", message: "Executing paid function...", preferredStyle: .alert)
                        alert.addAction(UIAlertAction(title: "OK", style: .default))
                        self?.present(alert, animated: true)
                    }
                    callback?("Feature Executed")
                }


                self.bridge?.register(handlerName: "premiumFeature2") { [weak self] (parameters, callback) in
                    // 1. Extract User ID from the JS call
                    guard let data = parameters as? [String: Any],
                          let userId = data["userId"] as? String else {
                        callback?("Error: Missing User ID")
                        return
                    }
                
                    // 2. Define your Server URL
                    let url = URL(string: "https://your-api.com/check-subscription?uid=\(userId)")!
                    
                    // 3. Perform a Native Network Request
                    let task = URLSession.shared.dataTask(with: url) { (data, response, error) in
                        if let data = data, let responseString = String(data: data, encoding: .utf8) {
                            
                            // 4. Check if Server returned "Yes" (or 1, or a valid token)
                            if responseString.contains("Yes") {
                                DispatchQueue.main.async {
                                    // --- PROTECTED NATIVE LOGIC START ---
                                    let alert = UIAlertController(title: "Verified", message: "Premium access granted!", preferredStyle: .alert)
                                    alert.addAction(UIAlertAction(title: "OK", style: .default))
                                    self?.present(alert, animated: true)
                                    // --- PROTECTED NATIVE LOGIC END ---
                                    
                                    callback?("Access Granted")
                                }
                            } else {
                                callback?("Error: Subscription inactive")
                            }
                        } else {
                            callback?("Error: Server unreachable")
                        }
                    }
                    task.resume()
                }

                
                  let url = URL(string: "https://snippets.marketingpipeliners.com")!
                  webView.load(URLRequest(url: url))
              }

              func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
                  // Call JS Handler from Native once page finishes loading
                  self.bridge?.call(handlerName: "testJavascriptHandler", data: ["foo": "before ready"], callback: { response in
                      print("JS responded: \(String(describing: response))")
                  })

                  // Visual confirmation
                  webView.evaluateJavaScript("alert('Bridge Initialized');")
                  webView.evaluateJavaScript("window._SETTINGS.APPTYPE = 'ios';")
              }

              // Handle JavaScript Alerts (alert, confirm, prompt)
              func webView(_ webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping () -> Void) {
                  let alert = UIAlertController(title: "JS Alert", message: message, preferredStyle: .alert)
                  alert.addAction(UIAlertAction(title: "OK", style: .default) { _ in completionHandler() })
                  present(alert, animated: true)
              }
          
              func webView(_ webView: WKWebView, runJavaScriptConfirmPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (Bool) -> Void) {
                  let confirmAlert = UIAlertController(title: "JS Confirm", message: message, preferredStyle: .alert)
                  confirmAlert.addAction(UIAlertAction(title: "Cancel", style: .cancel) { _ in
                      completionHandler(false) // User pressed Cancel
                  })
                  confirmAlert.addAction(UIAlertAction(title: "OK", style: .default) { _ in
                      completionHandler(true) // User pressed OK
                  })
                  present(confirmAlert, animated: true)
              }
          
              func webView(_ webView: WKWebView, runJavaScriptTextInputPanelWithPrompt prompt: String, defaultText: String?, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (String?) -> Void) {
                  let promptAlert = UIAlertController(title: "JS Prompt", message: prompt, preferredStyle: .alert)
                  
                  // Add a text field for the user to input
                  promptAlert.addTextField { textField in
                      textField.text = defaultText
                  }
          
                  promptAlert.addAction(UIAlertAction(title: "Cancel", style: .cancel) { _ in
                      completionHandler(nil) // User pressed Cancel
                  })
                  promptAlert.addAction(UIAlertAction(title: "OK", style: .default) { _ in
                      let text = promptAlert.textFields?.first?.text
                      completionHandler(text) // User entered some text
                  })
                  
                  present(promptAlert, animated: true)
              }
          }
          EOF

          # 2. Create Info.plist for the project
          cat <<EOF > Info.plist
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>CFBundleExecutable</key>
              <string>WebKitApp</string>
              <key>CFBundleIdentifier</key>
              <string>com.example.webkitapp</string>
              <key>CFBundleName</key>
              <string>WebKitApp</string>
              <key>CFBundlePackageType</key>
              <string>APPL</string>
              <key>CFBundleShortVersionString</key>
              <string>1.0</string>
              <key>CFBundleVersion</key>
              <string>1</string>
              <key>LSRequiresIPhoneOS</key>
              <true/>
              <key>UILaunchScreen</key>
              <dict/>
              <key>NSAppTransportSecurity</key>
              <dict>
                  <key>NSAllowsArbitraryLoads</key>
                  <true/>
              </dict>
              <key>UIBackgroundModes</key>
              <array>
                  <string>fetch</string>
                  <string>processing</string>
              </array>
              <key>BGTaskSchedulerPermittedIdentifiers</key>
              <array>
                  <string>com.example.webkitapp.refresh</string>
              </array>
              <key>CFBundleURLTypes</key>
              <array>
                  <dict>
                      <key>CFBundleURLSchemes</key>
                      <array>
                          <string>mywebkitapp</string>
                      </array>
                  </dict>
              </array>
          </dict>
          </plist>
          EOF

      - name: Create Xcode Project
        run: |
          # Create Xcode Project and add the app target and share extension
          gem install xcodeproj
          gem install nokogiri
          ruby -e "
          require 'xcodeproj'
          require 'nokogiri'
          require 'fileutils'  # For creating directories
      
          # Create a new Xcode project
          project = Xcodeproj::Project.new('WebKitApp.xcodeproj')
      
          # Create app target
          target = project.new_target(:application, 'WebKitApp', :ios, '15.0')
      
          # Add app files (AppDelegate.swift, Info.plist)
          app_delegate = project.new_file('AppDelegate.swift')
          info_plist = project.new_file('Info.plist')
          target.add_file_references([app_delegate])
      
          # Set build configurations for the app target
          target.build_configurations.each do |config|
            config.build_settings['INFOPLIST_FILE'] = 'Info.plist'
            config.build_settings['GENERATE_INFOPLIST_FILE'] = 'NO'
            config.build_settings['PRODUCT_BUNDLE_IDENTIFIER'] = 'com.example.webkitapp'
            config.build_settings['SWIFT_VERSION'] = '5.0'
            config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '15.0'
          end
      
          # Create Share Extension target
          extension_target = project.new_target(:app_extension, 'ShareExtension', :ios, '15.0')
          extension_target.product_type = 'com.apple.product-type.app-extension'
      
          # Ensure the ShareExtension directory exists
          extension_dir = 'ShareExtension'
          FileUtils.mkdir_p(extension_dir) unless File.exist?(extension_dir)
      
          # Generate XML content for the extension's Info.plist
          extension_plist = {
            'CFBundleDisplayName' => 'Send to WebKit',
            'NSExtension' => {
              'NSExtensionAttributes' => {
                'NSExtensionActivationRule' => 'TRUEPREDICATE' # Accept everything
              },
              'NSExtensionMainStoryboard' => 'MainInterface',
              'NSExtensionPointIdentifier' => 'com.apple.share-services'
            }
          }

          # Use Nokogiri to convert the hash to XML format
          builder = Nokogiri::XML::Builder.new(encoding: 'UTF-8') do |xml|
            xml.plist(version: '1.0') {
              xml.dict {
                extension_plist.each do |key, value|
                  if value.is_a? Hash
                    xml.key key
                    xml.dict {
                      value.each do |sub_key, sub_value|
                        xml.key sub_key
                        xml.string sub_value
                      end
                    }
                  else
                    xml.key key
                    xml.string value
                  end
                end
              }
            }
          end
      
          # Save the generated XML to the Info.plist file for the extension
          extension_plist_file = "#{extension_dir}/Info.plist"
          File.write(extension_plist_file, builder.to_xml(indent: 2))
      
          # Add the Info.plist to the extension target
          extension_target.build_configurations.each do |config|
            config.build_settings['INFOPLIST_FILE'] = extension_plist_file
            config.build_settings['GENERATE_INFOPLIST_FILE'] = 'NO'
            config.build_settings['PRODUCT_BUNDLE_IDENTIFIER'] = 'com.example.webkitapp.shareextension'
            config.build_settings['SWIFT_VERSION'] = '5.0'
            config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '15.0'
          end
      
          # Ensure a shared scheme is created for CI visibility
          project.recreate_user_schemes
          project.save
          "


      - name: Create and Install Pods
        run: |
          cat <<EOF > Podfile
          platform :ios, '15.0'
          use_frameworks!
          target 'WebKitApp' do
            pod 'WKWebViewJavascriptBridge', '~> 1.2.0'
          end

          post_install do |installer|
            installer.pods_project.targets.each do |target|
              target.build_configurations.each do |config|
                config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '15.0'
              end
            end
          end
          EOF
          pod install

      - name: Build Archive (Unsigned)
        run: |
          xcodebuild archive \
            -workspace WebKitApp.xcworkspace \
            -scheme WebKitApp \
            -configuration Release \
            -archivePath ./build/WebKitApp.xcarchive \
            CODE_SIGNING_ALLOWED=NO \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGN_IDENTITY="" \
            AD_HOC_CODE_SIGNING_ALLOWED=YES

      - name: Package IPA
        run: |
          mkdir -p Payload
          cp -r ./build/WebKitApp.xcarchive/Products/Applications/*.app ./Payload/
          zip -r WebKitApp-Unsigned.ipa Payload

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: WebKit-WebView-IPA
          path: WebKitApp-Unsigned.ipa
