name: Build WebKit WebView iOS IPA

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build:
    runs-on: macos-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set up Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: 'latest-stable'

      - name: Generate Source Files
        run: |
          # 1. Create AppDelegate.swift with Full Bridge Logic
          cat <<EOF > AppDelegate.swift
          import UIKit
          import WebKit
          import WKWebViewJavascriptBridge
          import AVFoundation
          import UserNotifications
          import BackgroundTasks

          @main
          class AppDelegate: UIResponder, UIApplicationDelegate {
              var window: UIWindow?
              var mainViewController: ViewController? 
              
              func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
                  window = UIWindow(frame: UIScreen.main.bounds)
                  let vc = ViewController()
                  mainViewController = vc
                  window?.rootViewController = vc
                  window?.makeKeyAndVisible()
                  BGTaskScheduler.shared.register(forTaskWithIdentifier: "com.example.webkitapp.refresh", using: nil) { task in
                      self.handleAppRefresh(task: task as! BGAppRefreshTask)
                  }     
                  
                  // Check for shared data after a delay to ensure WebView is ready
                  DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                      self.checkForSharedData()
                  }
                  
                  return true
              }
              
              // Handle URL scheme opens (when share extension opens the app)
              func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {
                  if url.scheme == "webkitapp" {
                      // Give WebView time to load, then check for shared data
                      DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                          self.checkForSharedData()
                      }
                      return true
                  }
                  return false
              }

              func checkForSharedData() {
                  guard let sharedDefaults = UserDefaults(suiteName: "group.com.example.webkitapp") else {
                      print("âŒ Could not access shared defaults")
                      return
                  }
                  
                  // Check for shared text
                  if let sharedText = sharedDefaults.string(forKey: "SharedText") {
                      print("ðŸ“± Found shared text: \(sharedText.prefix(50))...")
                      sharedDefaults.removeObject(forKey: "SharedText")
                      sharedDefaults.removeObject(forKey: "SharedTimestamp")
                      sharedDefaults.synchronize()
                      
                      self.mainViewController?.handleSharedContent(text: sharedText)
                  }
                  
                  // Check for shared URL
                  if let sharedURL = sharedDefaults.string(forKey: "SharedURL") {
                      print("ðŸ“± Found shared URL: \(sharedURL)")
                      sharedDefaults.removeObject(forKey: "SharedURL")
                      sharedDefaults.removeObject(forKey: "SharedTimestamp")
                      sharedDefaults.synchronize()
                      
                      self.mainViewController?.handleSharedContent(url: sharedURL)
                  }
              }

              func handleAppRefresh(task: BGAppRefreshTask) {
                  let request = BGAppRefreshTaskRequest(identifier: "com.example.webkitapp.refresh")
                  request.earliestBeginDate = Date(timeIntervalSinceNow: 3600)
                  try? BGTaskScheduler.shared.submit(request)
          
                  DispatchQueue.main.async {
                      self.mainViewController?.bridge?.call(handlerName: "onBackgroundSync", data: ["time": Date().description]) { response in
                          task.setTaskCompleted(success: true)
                      }
                  }
              }

              func scheduleAppRefresh() {
                  let request = BGAppRefreshTaskRequest(identifier: "com.example.webkitapp.refresh")
                  request.earliestBeginDate = Date(timeIntervalSinceNow: 2 * 60 * 60)
                  try? BGTaskScheduler.shared.submit(request)
              }
              
          }

          class ViewController: UIViewController, WKNavigationDelegate, WKUIDelegate, UNUserNotificationCenterDelegate {
              var webView: WKWebView!
              var bridge: WKWebViewJavascriptBridge?

              func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
                  completionHandler([.banner, .sound])
              }

              // MARK: - Handle Shared Content
              func handleSharedContent(text: String) {
                  bridge?.call(handlerName: "onSharedText", data: ["text": text]) { response in
                      print("Shared text handled: \(String(describing: response))")
                  }
              }
              
              func handleSharedContent(url: String) {
                  bridge?.call(handlerName: "onSharedURL", data: ["url": url]) { response in
                      print("Shared URL handled: \(String(describing: response))")
                  }
              }

              // MARK: - Bridge Response Helper
              struct BridgeResponse {
                  static func success(_ data: Any? = nil, message: String? = nil) -> [String: Any] {
                      var response: [String: Any] = ["success": true]
                      if let data = data {
                          response["data"] = data
                      }
                      if let message = message {
                          response["message"] = message
                      }
                      return response
                  }
                  
                  static func error(_ message: String, code: String? = nil, details: Any? = nil) -> [String: Any] {
                      var response: [String: Any] = [
                          "success": false,
                          "error": message
                      ]
                      if let code = code {
                          response["errorCode"] = code
                      }
                      if let details = details {
                          response["details"] = details
                      }
                      return response
                  }
              }
              
              override func loadView() {
                  let webConfiguration = WKWebViewConfiguration()

                  let jsSetup = """
                  function setupWKWebViewJavascriptBridge(callback) {
                      if (window.WKWebViewJavascriptBridge) { return callback(WKWebViewJavascriptBridge); }
                      if (window.WKWVJBCallbacks) { return window.WKWVJBCallbacks.push(callback); }
                      window.WKWVJBCallbacks = [callback];
                      window.webkit.messageHandlers.iOS_Native_InjectJavascript.postMessage(null);
                  }

                  window.setupWKWebViewJavascriptBridge = setupWKWebViewJavascriptBridge;
                  """

                  let userScript = WKUserScript(source: jsSetup, injectionTime: .atDocumentStart, forMainFrameOnly: false)
                  webConfiguration.userContentController.addUserScript(userScript)
                  webConfiguration.applicationNameForUserAgent = "MyIOSApp"

                  webView = WKWebView(frame: .zero, configuration: webConfiguration)
                  webView.navigationDelegate = self
                  webView.uiDelegate = self
                  view = webView
              }

              override func viewDidLoad() {
                  super.viewDidLoad()
                  if #available(iOS 16.4, *) {
                      webView.isInspectable = false 
                  }
                  UNUserNotificationCenter.current().delegate = self
                  self.bridge = WKWebViewJavascriptBridge(webView: webView)

                  self.bridge?.register(handlerName: "testiOSCallback") { (parameters, callback) in
                      print("testiOSCallback called with: \(String(describing: parameters))")
                      callback?("Response from testiOSCallback")
                  }

                  self.bridge?.register(handlerName: "scheduleBackgroundSync") { (parameters, callback) in
                      let hours = (parameters as? [String: Any])?["hours"] as? Double ?? 2.0
                      
                      let request = BGAppRefreshTaskRequest(identifier: "com.example.webkitapp.refresh")
                      request.earliestBeginDate = Date(timeIntervalSinceNow: hours * 3600)
                      
                      do {
                          try BGTaskScheduler.shared.submit(request)
                          callback?("Successfully scheduled for \(hours) hours from now")
                      } catch {
                          callback?("Error: \(error.localizedDescription)")
                      }
                  }

                  self.bridge?.register(handlerName: "showNotification") { [weak self] (parameters, callback) in
                      print("testiOSCallback called with: \(String(describing: parameters))")
                      
                      DispatchQueue.main.async {
                          guard let strongSelf = self else { return }
                          
                          if strongSelf.presentedViewController != nil {
                              print("An alert is already being presented.")
                              return
                          }
                  
                          let jsData = parameters as? [String: Any]
                          let messageBody = jsData?["message"] as? String ?? "Notification from WebKit"
                          
                          let alert = UIAlertController(
                              title: "iOS Notification",
                              message: messageBody,
                              preferredStyle: .alert
                          )
                          
                          alert.addAction(UIAlertAction(title: "OK", style: .default, handler: nil))
                          strongSelf.present(alert, animated: true, completion: nil)
                      }
                      
                      callback?("Response from testiOSCallback")
                  }

                  self.bridge?.register(handlerName: "vibrate") { (parameters, _) in
                      DispatchQueue.main.async {
                          let generator = UIImpactFeedbackGenerator(style: .medium)
                          generator.impactOccurred()
                      }
                  }

                  self.bridge?.register(handlerName: "getDeviceInfo") { (_, callback) in
                      UIDevice.current.isBatteryMonitoringEnabled = true
                      let info = [
                          "model": UIDevice.current.model,
                          "battery": "\(UIDevice.current.batteryLevel * 100)%",
                          "system": UIDevice.current.systemVersion
                      ]
                      callback?(info)
                  }

                  self.bridge?.register(handlerName: "setBrightness") { (parameters, _) in
                      if let level = (parameters as? [String: Any])?["level"] as? CGFloat {
                          DispatchQueue.main.async { UIScreen.main.brightness = level }
                      }
                  }             

                  self.bridge?.register(handlerName: "nativeShare") { [weak self] (parameters, _) in
                      guard let text = (parameters as? [String: Any])?["text"] as? String else { return }
                      DispatchQueue.main.async {
                          let ac = UIActivityViewController(activityItems: [text], applicationActivities: nil)
                          self?.present(ac, animated: true)
                      }
                  }             

                  self.bridge?.register(handlerName: "saveSecure") { (parameters, callback) in
                      let data = parameters as? [String: Any]
                      let key = data?["key"] as? String ?? "default"
                      let value = data?["value"] as? String ?? ""
                  
                      let query: [String: Any] = [
                          kSecClass as String: kSecClassGenericPassword,
                          kSecAttrAccount as String: key,
                          kSecValueData as String: value.data(using: .utf8)!
                      ]
                      SecItemDelete(query as CFDictionary)
                      let status = SecItemAdd(query as CFDictionary, nil)
                      callback?(status == errSecSuccess ? "Success" : "Error")
                  }

                  self.bridge?.register(handlerName: "clearCookies") { (_, callback) in
                      DispatchQueue.main.async {
                          let dataStore = WKWebsiteDataStore.default()
                          let types = WKWebsiteDataStore.allWebsiteDataTypes()
                          let dateFrom = Date(timeIntervalSince1970: 0)
                  
                          dataStore.removeData(ofTypes: types, modifiedSince: dateFrom) {
                              callback?("Cookies Cleared")
                          }
                      }
                  }              

                  self.bridge?.register(handlerName: "toggleFlashlight") { (parameters, callback) in
                      guard let device = AVCaptureDevice.default(for: .video), device.hasTorch else {
                          callback?("Error: Hardware not available")
                          return 
                      }
                      
                      let isOn = (parameters as? [String: Any])?["on"] as? Bool ?? false
                      
                      do {
                          try device.lockForConfiguration()
                          device.torchMode = isOn ? .on : .off
                          device.unlockForConfiguration()
                          callback?("Flashlight set to \(isOn)") 
                      } catch {
                          callback?("Error: Could not lock hardware")
                      }
                  }

                  self.bridge?.register(handlerName: "showLocalPush") { (parameters, callback) in
                      let center = UNUserNotificationCenter.current()
                      
                      center.requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in
                          if granted {
                              let data = parameters as? [String: Any]
                              let title = data?["title"] as? String ?? "New Message"
                              let body = data?["body"] as? String ?? "You have a new notification."
                              
                              let content = UNMutableNotificationContent()
                              content.title = title
                              content.body = body
                              content.sound = .default
                              
                              let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)
                              
                              let request = UNNotificationRequest(
                                  identifier: UUID().uuidString, 
                                  content: content, 
                                  trigger: trigger
                              )
                              
                              center.add(request) { (error) in
                                  if let error = error {
                                      callback?("Error: \(error.localizedDescription)")
                                  } else {
                                      callback?("Notification Scheduled")
                                  }
                              }
                          } else {
                              callback?("Permission Denied")
                          }
                      }
                  }

                  self.bridge?.register(handlerName: "openURL") { (parameters, _) in
                      guard let urlString = (parameters as? [String: Any])?["url"] as? String,
                            let url = URL(string: urlString) else { return }
                      DispatchQueue.main.async {
                          if UIApplication.shared.canOpenURL(url) {
                              UIApplication.shared.open(url, options: [:], completionHandler: nil)
                          } else {
                              print("App not installed or invalid URL")
                          }
                      }
                  }

                  self.bridge?.register(handlerName: "requestNotificationPermission") { (parameters, callback) in
                      let center = UNUserNotificationCenter.current()
                      
                      center.requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in
                          if let error = error {
                              callback?(false)
                          } else if granted {
                              callback?(granted)
                          } else {
                              callback?(false)
                          }
                      }
                  }

                  self.bridge?.register(handlerName: "lockOrientation") { (parameters, _) in
                      if let orientation = (parameters as? [String: Any])?["orientation"] as? String {
                          DispatchQueue.main.async {
                              if orientation == "portrait" {
                                  UIDevice.current.setValue(UIInterfaceOrientation.portrait.rawValue, forKey: "orientation")
                              } else if orientation == "landscape" {
                                  UIDevice.current.setValue(UIInterfaceOrientation.landscapeLeft.rawValue, forKey: "orientation")
                              }
                          }
                      }
                  }
                  
                  self.bridge?.register(handlerName: "getBatteryInfo") { (_, callback) in
                      UIDevice.current.isBatteryMonitoringEnabled = true
                      let batteryLevel = UIDevice.current.batteryLevel * 100
                      let batteryState: String
                      switch UIDevice.current.batteryState {
                      case .charging: batteryState = "Charging"
                      case .full: batteryState = "Full"
                      case .unplugged: batteryState = "Unplugged"
                      default: batteryState = "Unknown"
                      }
                      callback?(["batteryLevel": "\(batteryLevel)%", "batteryState": batteryState])
                  }
                  
                  self.bridge?.register(handlerName: "openMaps") { (parameters, _) in
                      guard let address = (parameters as? [String: Any])?["address"] as? String else { return }
                      DispatchQueue.main.async {
                          let urlString = "https://maps.apple.com/?q=\(address)"
                          if let url = URL(string: urlString) {
                              UIApplication.shared.open(url, options: [:], completionHandler: nil)
                          }
                      }
                  }

                  func isUserPremium() -> Bool {
                      return UserDefaults.standard.bool(forKey: "isPremiumUser")
                  }
                  
                  self.bridge?.register(handlerName: "unlockPremium") { (_, callback) in
                      UserDefaults.standard.set(true, forKey: "isPremiumUser")
                      callback?("Success: Premium Unlocked")
                  }
                  
                  self.bridge?.register(handlerName: "premiumFeature") { [weak self] (parameters, callback) in
                      guard isUserPremium() else {
                          callback?("Error: This is a paid feature. Please upgrade.")
                          return
                      }
                      
                      DispatchQueue.main.async {
                          let alert = UIAlertController(title: "Premium Access", message: "Executing paid function...", preferredStyle: .alert)
                          alert.addAction(UIAlertAction(title: "OK", style: .default))
                          self?.present(alert, animated: true)
                      }
                      callback?("Feature Executed")
                  }

                  self.bridge?.register(handlerName: "premiumFeature2") { [weak self] (parameters, callback) in
                      guard let data = parameters as? [String: Any],
                            let userId = data["userId"] as? String else {
                          callback?("Error: Missing User ID")
                          return
                      }
                  
                      let url = URL(string: "https://your-api.com/check-subscription?uid=\(userId)")!
                      
                      let task = URLSession.shared.dataTask(with: url) { (data, response, error) in
                          if let data = data, let responseString = String(data: data, encoding: .utf8) {
                              
                              if responseString.contains("Yes") {
                                  DispatchQueue.main.async {
                                      let alert = UIAlertController(title: "Verified", message: "Premium access granted!", preferredStyle: .alert)
                                      alert.addAction(UIAlertAction(title: "OK", style: .default))
                                      self?.present(alert, animated: true)
                                      
                                      callback?("Access Granted")
                                  }
                              } else {
                                  callback?("Error: Subscription inactive")
                              }
                          } else {
                              callback?("Error: Server unreachable")
                          }
                      }
                      task.resume()
                  }
                  
                  let url = URL(string: "https://snippets.marketingpipeliners.com")!
                  webView.load(URLRequest(url: url))
              }

              func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
                  self.bridge?.call(handlerName: "testJavascriptHandler", data: ["foo": "before ready"], callback: { response in
                      print("JS responded: \(String(describing: response))")
                  })

                  webView.evaluateJavaScript("alert('Bridge Initialized');")
                  webView.evaluateJavaScript("window._SETTINGS.APPTYPE = 'ios';")
              }

              func webView(_ webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping () -> Void) {
                  let alert = UIAlertController(title: "JS Alert", message: message, preferredStyle: .alert)
                  alert.addAction(UIAlertAction(title: "OK", style: .default) { _ in completionHandler() })
                  present(alert, animated: true)
              }
          
              func webView(_ webView: WKWebView, runJavaScriptConfirmPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (Bool) -> Void) {
                  let confirmAlert = UIAlertController(title: "JS Confirm", message: message, preferredStyle: .alert)
                  confirmAlert.addAction(UIAlertAction(title: "Cancel", style: .cancel) { _ in
                      completionHandler(false)
                  })
                  confirmAlert.addAction(UIAlertAction(title: "OK", style: .default) { _ in
                      completionHandler(true)
                  })
                  present(confirmAlert, animated: true)
              }
          
              func webView(_ webView: WKWebView, runJavaScriptTextInputPanelWithPrompt prompt: String, defaultText: String?, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (String?) -> Void) {
                  let promptAlert = UIAlertController(title: "JS Prompt", message: prompt, preferredStyle: .alert)
                  
                  promptAlert.addTextField { textField in
                      textField.text = defaultText
                  }
          
                  promptAlert.addAction(UIAlertAction(title: "Cancel", style: .cancel) { _ in
                      completionHandler(nil)
                  })
                  promptAlert.addAction(UIAlertAction(title: "OK", style: .default) { _ in
                      let text = promptAlert.textFields?.first?.text
                      completionHandler(text)
                  })
                  
                  present(promptAlert, animated: true)
              }
          }
          EOF

          # 2. Create ShareViewController.swift for the Share Extension
          cat <<EOF > ShareViewController.swift
          import UIKit
          import Social
          import MobileCoreServices
          import UniformTypeIdentifiers

          class ShareViewController: UIViewController {
              
              override func viewDidLoad() {
                  super.viewDidLoad()
                  
                  // Process the shared content immediately
                  processSharedContent()
              }
              
              func processSharedContent() {
                  guard let extensionItem = extensionContext?.inputItems.first as? NSExtensionItem,
                        let attachments = extensionItem.attachments else {
                      closeExtension()
                      return
                  }
                  
                  // Try to find text or URL content
                  for itemProvider in attachments {
                      // Priority 1: Plain Text (works with Notes)
                      if itemProvider.hasItemConformingToTypeIdentifier(UTType.plainText.identifier) {
                          itemProvider.loadItem(forTypeIdentifier: UTType.plainText.identifier, options: nil) { [weak self] (item, error) in
                              if let text = item as? String {
                                  self?.saveSharedData(text: text)
                              } else if let data = item as? Data, let text = String(data: data, encoding: .utf8) {
                                  self?.saveSharedData(text: text)
                              }
                              self?.openMainAppAndClose()
                          }
                          return
                      }
                      
                      // Priority 2: URL
                      if itemProvider.hasItemConformingToTypeIdentifier(UTType.url.identifier) {
                          itemProvider.loadItem(forTypeIdentifier: UTType.url.identifier, options: nil) { [weak self] (item, error) in
                              if let url = item as? URL {
                                  self?.saveSharedData(url: url.absoluteString)
                              }
                              self?.openMainAppAndClose()
                          }
                          return
                      }
                      
                      // Priority 3: Generic Text
                      if itemProvider.hasItemConformingToTypeIdentifier(UTType.text.identifier) {
                          itemProvider.loadItem(forTypeIdentifier: UTType.text.identifier, options: nil) { [weak self] (item, error) in
                              if let text = item as? String {
                                  self?.saveSharedData(text: text)
                              }
                              self?.openMainAppAndClose()
                          }
                          return
                      }
                  }
                  
                  // If no compatible content found, just close
                  closeExtension()
              }
              
              func saveSharedData(text: String) {
                  if let sharedDefaults = UserDefaults(suiteName: "group.com.example.webkitapp") {
                      sharedDefaults.set(text, forKey: "SharedText")
                      sharedDefaults.set(Date().timeIntervalSince1970, forKey: "SharedTimestamp")
                      sharedDefaults.synchronize()
                      print("âœ… Saved shared text: \(text.prefix(50))...")
                  }
              }
              
              func saveSharedData(url: String) {
                  if let sharedDefaults = UserDefaults(suiteName: "group.com.example.webkitapp") {
                      sharedDefaults.set(url, forKey: "SharedURL")
                      sharedDefaults.set(Date().timeIntervalSince1970, forKey: "SharedTimestamp")
                      sharedDefaults.synchronize()
                      print("âœ… Saved shared URL: \(url)")
                  }
              }
              
              func openMainAppAndClose() {
                  DispatchQueue.main.async { [weak self] in
                      // Try to open the main app
                      if let url = URL(string: "webkitapp://shared") {
                          self?.openURL(url)
                      }
                      
                      // Close the extension after a brief delay
                      DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                          self?.closeExtension()
                      }
                  }
              }
              
              func closeExtension() {
                  self.extensionContext?.completeRequest(returningItems: nil, completionHandler: nil)
              }
              
              @objc func openURL(_ url: URL) {
                  var responder: UIResponder? = self
                  while responder != nil {
                      if let application = responder as? UIApplication {
                          application.perform(#selector(openURL(_:)), with: url)
                          return
                      }
                      responder = responder?.next
                  }
              }
          }
          EOF

          # 3. Create Info.plist for Share Extension
          cat <<EOF > ShareExtension-Info.plist
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>CFBundleDisplayName</key>
              <string>Share to WebKitApp</string>
              <key>CFBundleExecutable</key>
              <string>ShareExtension</string>
              <key>CFBundleIdentifier</key>
              <string>com.example.webkitapp.ShareExtension</string>
              <key>CFBundleName</key>
              <string>ShareExtension</string>
              <key>CFBundlePackageType</key>
              <string>XPC!</string>
              <key>CFBundleShortVersionString</key>
              <string>1.0</string>
              <key>CFBundleVersion</key>
              <string>1</string>
              <key>NSExtension</key>
              <dict>
                  <key>NSExtensionAttributes</key>
                  <dict>
                      <key>NSExtensionActivationRule</key>
                      <dict>
                          <key>NSExtensionActivationSupportsText</key>
                          <true/>
                          <key>NSExtensionActivationSupportsWebURLWithMaxCount</key>
                          <integer>1</integer>
                      </dict>
                  </dict>
                  <key>NSExtensionMainStoryboard</key>
                  <string>MainInterface</string>
                  <key>NSExtensionPointIdentifier</key>
                  <string>com.apple.share-services</string>
              </dict>
          </dict>
          </plist>
          EOF

          # 4. Create Main App Info.plist with URL scheme and App Groups
          cat <<EOF > Info.plist
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>CFBundleExecutable</key>
              <string>WebKitApp</string>
              <key>CFBundleIdentifier</key>
              <string>com.example.webkitapp</string>
              <key>CFBundleName</key>
              <string>WebKitApp</string>
              <key>CFBundlePackageType</key>
              <string>APPL</string>
              <key>CFBundleShortVersionString</key>
              <string>1.0</string>
              <key>CFBundleVersion</key>
              <string>1</string>
              <key>LSRequiresIPhoneOS</key>
              <true/>
              <key>UILaunchScreen</key>
              <dict/>
              <key>NSAppTransportSecurity</key>
              <dict>
                  <key>NSAllowsArbitraryLoads</key>
                  <true/>
              </dict>
              <key>UIBackgroundModes</key>
              <array>
                  <string>fetch</string>
                  <string>processing</string>
              </array>
              <key>BGTaskSchedulerPermittedIdentifiers</key>
              <array>
                  <string>com.example.webkitapp.refresh</string>
              </array>
              <key>CFBundleURLTypes</key>
              <array>
                  <dict>
                      <key>CFBundleURLSchemes</key>
                      <array>
                          <string>webkitapp</string>
                      </array>
                      <key>CFBundleURLName</key>
                      <string>com.example.webkitapp</string>
                  </dict>
              </array>
          </dict>
          </plist>
          EOF

          # 5. Create MainInterface.storyboard for Share Extension
          cat <<EOF > MainInterface.storyboard
          <?xml version="1.0" encoding="UTF-8"?>
          <document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="21507" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="j1y-V4-xli">
              <device id="retina6_1" orientation="portrait" appearance="light"/>
              <dependencies>
                  <deployment identifier="iOS"/>
                  <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="21505"/>
                  <capability name="Safe area layout guides" minToolsVersion="9.0"/>
                  <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
              </dependencies>
              <scenes>
                  <scene sceneID="ceB-am-kn3">
                      <objects>
                          <viewController id="j1y-V4-xli" customClass="ShareViewController" customModule="ShareExtension" customModuleProvider="target" sceneMemberID="viewController">
                          <view key="view" contentMode="scaleToFill" id="wbc-yd-nFH">
                              <rect key="frame" x="0.0" y="0.0" width="414" height="896"/>
                              <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                              <subviews>
                                  <label opaque="NO" userInteractionEnabled="NO" contentMode="left" horizontalHuggingPriority="251" verticalHuggingPriority="251" text="Sharing to WebKitApp..." textAlignment="center" lineBreakMode="tailTruncation" baselineAdjustment="alignBaselines" adjustsFontSizeToFit="NO" translatesAutoresizingMaskIntoConstraints="NO" id="9fh-lQ-2xg">
                                      <rect key="frame" x="107" y="437.5" width="200" height="21"/>
                                      <fontDescription key="fontDescription" type="system" pointSize="17"/>
                                      <nil key="textColor"/>
                                      <nil key="highlightedColor"/>
                                  </label>
                              </subviews>
                              <viewLayoutGuide key="safeArea" id="9Zq-Fj-Qhn"/>
                              <color key="backgroundColor" systemColor="systemBackgroundColor"/>
                              <constraints>
                                  <constraint firstItem="9fh-lQ-2xg" firstAttribute="centerX" secondItem="wbc-yd-nFH" secondAttribute="centerX" id="2Uo-Vy-gUk"/>
                                  <constraint firstItem="9fh-lQ-2xg" firstAttribute="centerY" secondItem="wbc-yd-nFH" secondAttribute="centerY" id="lKn-aB-vRr"/>
                              </constraints>
                          </view>
                      </viewController>
                      <placeholder placeholderIdentifier="IBFirstResponder" id="CEy-Cv-SGf" userLabel="First Responder" customClass="UIResponder" sceneMemberID="firstResponder"/>
                  </objects>
                  <point key="canvasLocation" x="119" y="149"/>
              </scene>
          </scenes>
          <resources>
              <systemColor name="systemBackgroundColor">
                  <color white="1" alpha="1" colorSpace="custom" customColorSpace="genericGamma22GrayColorSpace"/>
              </systemColor>
          </resources>
          </document>
          EOF

      - name: Create Xcode Project with Share Extension
        run: |
          gem install xcodeproj
          ruby -e "
          require 'xcodeproj'
          project = Xcodeproj::Project.new('WebKitApp.xcodeproj')
          
          # Create main app target
          target = project.new_target(:application, 'WebKitApp', :ios, '15.0')
          
          # Add files to main app
          app_delegate = project.new_file('AppDelegate.swift')
          info_plist = project.new_file('Info.plist')
          target.add_file_references([app_delegate])

          # Configure main app
          target.build_configurations.each do |config|
            config.build_settings['INFOPLIST_FILE'] = 'Info.plist'
            config.build_settings['GENERATE_INFOPLIST_FILE'] = 'NO'
            config.build_settings['PRODUCT_BUNDLE_IDENTIFIER'] = 'com.example.webkitapp'
            config.build_settings['SWIFT_VERSION'] = '5.0'
            config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '15.0'
            config.build_settings['CODE_SIGN_ENTITLEMENTS'] = 'WebKitApp.entitlements'
          end

          # Create Share Extension target
          share_target = project.new_target(:app_extension, 'ShareExtension', :ios, '15.0')
          
          # Add files to share extension
          share_view_controller = project.new_file('ShareViewController.swift')
          share_info_plist = project.new_file('ShareExtension-Info.plist')
          share_storyboard = project.new_file('MainInterface.storyboard')
          
          share_target.add_file_references([share_view_controller, share_storyboard])

          # Configure share extension
          share_target.build_configurations.each do |config|
            config.build_settings['INFOPLIST_FILE'] = 'ShareExtension-Info.plist'
            config.build_settings['GENERATE_INFOPLIST_FILE'] = 'NO'
            config.build_settings['PRODUCT_BUNDLE_IDENTIFIER'] = 'com.example.webkitapp.ShareExtension'
            config.build_settings['SWIFT_VERSION'] = '5.0'
            config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '15.0'
            config.build_settings['CODE_SIGN_ENTITLEMENTS'] = 'ShareExtension.entitlements'
            config.build_settings['SKIP_INSTALL'] = 'YES'
          end

          # Create target dependency
          target.add_dependency(share_target)

          # Create copy files build phase to embed the extension
          copy_phase = target.new_copy_files_build_phase('Embed App Extensions')
          copy_phase.dst_subfolder_spec = '13'
          copy_phase.add_file_reference(share_target.product_reference)

          project.recreate_user_schemes
          project.save
          "

          # Create App Groups entitlements for main app
          cat <<EOF > WebKitApp.entitlements
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>com.apple.security.application-groups</key>
              <array>
                  <string>group.com.example.webkitapp</string>
              </array>
          </dict>
          </plist>
          EOF

          # Create App Groups entitlements for share extension
          cat <<EOF > ShareExtension.entitlements
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>com.apple.security.application-groups</key>
              <array>
                  <string>group.com.example.webkitapp</string>
              </array>
          </dict>
          </plist>
          EOF

      - name: Create and Install Pods
        run: |
          cat <<EOF > Podfile
          platform :ios, '15.0'
          use_frameworks!

          target 'WebKitApp' do
            pod 'WKWebViewJavascriptBridge', '~> 1.2.0'
          end

          target 'ShareExtension' do
            # Share extension doesn't need any pods
          end

          post_install do |installer|
            installer.pods_project.targets.each do |target|
              target.build_configurations.each do |config|
                config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '15.0'
              end
            end
          end
          EOF
          pod install

      - name: Build Archive (Unsigned)
        run: |
          xcodebuild archive \
            -workspace WebKitApp.xcworkspace \
            -scheme WebKitApp \
            -configuration Release \
            -archivePath ./build/WebKitApp.xcarchive \
            CODE_SIGNING_ALLOWED=NO \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGN_IDENTITY="" \
            AD_HOC_CODE_SIGNING_ALLOWED=YES

      - name: Package IPA
        run: |
          mkdir -p Payload
          cp -r ./build/WebKitApp.xcarchive/Products/Applications/*.app ./Payload/
          zip -r WebKitApp-Unsigned.ipa Payload

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: WebKit-WebView-IPA
          path: WebKitApp-Unsigned.ipa
