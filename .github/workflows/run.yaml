name: Build WebKit WebView iOS IPA with Share Extension

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build:
    runs-on: macos-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set up Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: 'latest-stable'

      - name: Generate Source Files
        run: |
          # 1. Create AppDelegate.swift with URL scheme handler
          cat <<'EOF' > AppDelegate.swift
          import UIKit
          import WebKit
          import WKWebViewJavascriptBridge
          import AVFoundation
          import UserNotifications
          import BackgroundTasks

          @main
          class AppDelegate: UIResponder, UIApplicationDelegate {
              var window: UIWindow?
              var mainViewController: ViewController? 
              
              func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
                  window = UIWindow(frame: UIScreen.main.bounds)
                  let vc = ViewController()
                  mainViewController = vc
                  window?.rootViewController = vc
                  window?.makeKeyAndVisible()
                  
                  BGTaskScheduler.shared.register(forTaskWithIdentifier: "com.example.webkitapp.refresh", using: nil) { task in
                      self.handleAppRefresh(task: task as! BGAppRefreshTask)
                  }
                  
                  // Check if launched from share extension
                  if let url = launchOptions?[.url] as? URL {
                      self.handleIncomingURL(url)
                  }
                  
                  return true
              }
              
              // Handle URL scheme from share extension
              func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {
                  handleIncomingURL(url)
                  return true
              }
              
              private func handleIncomingURL(_ url: URL) {
                  if url.scheme == "webkitapp" && url.host == "shared" {
                      // Notify the web view that shared content is available
                      DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                          self.mainViewController?.notifySharedContent()
                      }
                  }
              }

              func handleAppRefresh(task: BGAppRefreshTask) {
                  let request = BGAppRefreshTaskRequest(identifier: "com.example.webkitapp.refresh")
                  request.earliestBeginDate = Date(timeIntervalSinceNow: 3600)
                  try? BGTaskScheduler.shared.submit(request)
          
                  DispatchQueue.main.async {
                      self.mainViewController?.bridge?.call(handlerName: "onBackgroundSync", data: ["time": Date().description]) { response in
                          task.setTaskCompleted(success: true)
                      }
                  }
              }

              func scheduleAppRefresh() {
                  let request = BGAppRefreshTaskRequest(identifier: "com.example.webkitapp.refresh")
                  request.earliestBeginDate = Date(timeIntervalSinceNow: 2 * 60 * 60)
                  try? BGTaskScheduler.shared.submit(request)
              }
          }

          class ViewController: UIViewController, WKNavigationDelegate, WKUIDelegate, UNUserNotificationCenterDelegate {
              var webView: WKWebView!
              var bridge: WKWebViewJavascriptBridge?

              func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
                  completionHandler([.banner, .sound])
              }

              struct BridgeResponse {
                  static func success(_ data: Any? = nil, message: String? = nil) -> [String: Any] {
                      var response: [String: Any] = ["success": true]
                      if let data = data {
                          response["data"] = data
                      }
                      if let message = message {
                          response["message"] = message
                      }
                      return response
                  }
                  
                  static func error(_ message: String, code: String? = nil, details: Any? = nil) -> [String: Any] {
                      var response: [String: Any] = [
                          "success": false,
                          "error": message
                      ]
                      if let code = code {
                          response["errorCode"] = code
                      }
                      if let details = details {
                          response["details"] = details
                      }
                      return response
                  }
              }
              
              override func loadView() {
                  let webConfiguration = WKWebViewConfiguration()

                  let jsSetup = """
                  function setupWKWebViewJavascriptBridge(callback) {
                      if (window.WKWebViewJavascriptBridge) { return callback(WKWebViewJavascriptBridge); }
                      if (window.WKWVJBCallbacks) { return window.WKWVJBCallbacks.push(callback); }
                      window.WKWVJBCallbacks = [callback];
                      window.webkit.messageHandlers.iOS_Native_InjectJavascript.postMessage(null);
                  }

                  window.setupWKWebViewJavascriptBridge = setupWKWebViewJavascriptBridge;
                  """

                  let userScript = WKUserScript(source: jsSetup, injectionTime: .atDocumentStart, forMainFrameOnly: false)
                  webConfiguration.userContentController.addUserScript(userScript)
                  webConfiguration.applicationNameForUserAgent = "MyIOSApp"

                  webView = WKWebView(frame: .zero, configuration: webConfiguration)
                  webView.navigationDelegate = self
                  webView.uiDelegate = self
                  view = webView
              }

              override func viewDidLoad() {
                  super.viewDidLoad()
                  if #available(iOS 16.4, *) {
                      webView.isInspectable = false 
                  }
                  UNUserNotificationCenter.current().delegate = self
                  self.bridge = WKWebViewJavascriptBridge(webView: webView)

                  // Register all handlers
                  registerAllHandlers()

                  let url = URL(string: "https://snippets.marketingpipeliners.com")!
                  webView.load(URLRequest(url: url))
              }
              
              func notifySharedContent() {
                  // Call JavaScript to notify about shared content
                  self.bridge?.call(handlerName: "onSharedContent", data: ["available": true])
              }
              
              func registerAllHandlers() {
                  self.bridge?.register(handlerName: "testiOSCallback") { (parameters, callback) in
                      print("testiOSCallback called with: \(String(describing: parameters))")
                      callback?("Response from testiOSCallback")
                  }

                  self.bridge?.register(handlerName: "scheduleBackgroundSync") { (parameters, callback) in
                      let hours = (parameters as? [String: Any])?["hours"] as? Double ?? 2.0
                      let request = BGAppRefreshTaskRequest(identifier: "com.example.webkitapp.refresh")
                      request.earliestBeginDate = Date(timeIntervalSinceNow: hours * 3600)
                      do {
                          try BGTaskScheduler.shared.submit(request)
                          callback?("Successfully scheduled for \(hours) hours from now")
                      } catch {
                          callback?("Error: \(error.localizedDescription)")
                      }
                  }

                  self.bridge?.register(handlerName: "showNotification") { [weak self] (parameters, callback) in
                      DispatchQueue.main.async {
                          guard let strongSelf = self else { return }
                          if strongSelf.presentedViewController != nil {
                              print("An alert is already being presented.")
                              return
                          }
                          let jsData = parameters as? [String: Any]
                          let messageBody = jsData?["message"] as? String ?? "Notification from WebKit"
                          let alert = UIAlertController(title: "iOS Notification", message: messageBody, preferredStyle: .alert)
                          alert.addAction(UIAlertAction(title: "OK", style: .default, handler: nil))
                          strongSelf.present(alert, animated: true, completion: nil)
                      }
                      callback?("Response from testiOSCallback")
                  }

                  self.bridge?.register(handlerName: "vibrate") { (parameters, _) in
                      DispatchQueue.main.async {
                          let generator = UIImpactFeedbackGenerator(style: .medium)
                          generator.impactOccurred()
                      }
                  }

                  self.bridge?.register(handlerName: "getDeviceInfo") { (_, callback) in
                      UIDevice.current.isBatteryMonitoringEnabled = true
                      let info = [
                          "model": UIDevice.current.model,
                          "battery": "\(UIDevice.current.batteryLevel * 100)%",
                          "system": UIDevice.current.systemVersion
                      ]
                      callback?(info)
                  }

                  self.bridge?.register(handlerName: "setBrightness") { (parameters, _) in
                      if let level = (parameters as? [String: Any])?["level"] as? CGFloat {
                          DispatchQueue.main.async { UIScreen.main.brightness = level }
                      }
                  }

                  self.bridge?.register(handlerName: "nativeShare") { [weak self] (parameters, _) in
                      guard let text = (parameters as? [String: Any])?["text"] as? String else { return }
                      DispatchQueue.main.async {
                          let ac = UIActivityViewController(activityItems: [text], applicationActivities: nil)
                          self?.present(ac, animated: true)
                      }
                  }

                  self.bridge?.register(handlerName: "saveSecure") { (parameters, callback) in
                      let data = parameters as? [String: Any]
                      let key = data?["key"] as? String ?? "default"
                      let value = data?["value"] as? String ?? ""
                      let query: [String: Any] = [
                          kSecClass as String: kSecClassGenericPassword,
                          kSecAttrAccount as String: key,
                          kSecValueData as String: value.data(using: .utf8)!
                      ]
                      SecItemDelete(query as CFDictionary)
                      let status = SecItemAdd(query as CFDictionary, nil)
                      callback?(status == errSecSuccess ? "Success" : "Error")
                  }

                  self.bridge?.register(handlerName: "clearCookies") { (_, callback) in
                      DispatchQueue.main.async {
                          let dataStore = WKWebsiteDataStore.default()
                          let types = WKWebsiteDataStore.allWebsiteDataTypes()
                          let dateFrom = Date(timeIntervalSince1970: 0)
                          dataStore.removeData(ofTypes: types, modifiedSince: dateFrom) {
                              callback?("Cookies Cleared")
                          }
                      }
                  }

                  self.bridge?.register(handlerName: "toggleFlashlight") { (parameters, callback) in
                      guard let device = AVCaptureDevice.default(for: .video), device.hasTorch else {
                          callback?("Error: Hardware not available")
                          return 
                      }
                      let isOn = (parameters as? [String: Any])?["on"] as? Bool ?? false
                      do {
                          try device.lockForConfiguration()
                          device.torchMode = isOn ? .on : .off
                          device.unlockForConfiguration()
                          callback?("Flashlight set to \(isOn)") 
                      } catch {
                          callback?("Error: Could not lock hardware")
                      }
                  }

                  self.bridge?.register(handlerName: "showLocalPush") { (parameters, callback) in
                      let center = UNUserNotificationCenter.current()
                      center.requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in
                          if granted {
                              let data = parameters as? [String: Any]
                              let title = data?["title"] as? String ?? "New Message"
                              let body = data?["body"] as? String ?? "You have a new notification."
                              let content = UNMutableNotificationContent()
                              content.title = title
                              content.body = body
                              content.sound = .default
                              let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)
                              let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)
                              center.add(request) { (error) in
                                  if let error = error {
                                      callback?("Error: \(error.localizedDescription)")
                                  } else {
                                      callback?("Notification Scheduled")
                                  }
                              }
                          } else {
                              callback?("Permission Denied")
                          }
                      }
                  }

                  self.bridge?.register(handlerName: "openURL") { (parameters, _) in
                      guard let urlString = (parameters as? [String: Any])?["url"] as? String,
                            let url = URL(string: urlString) else { return }
                      DispatchQueue.main.async {
                          if UIApplication.shared.canOpenURL(url) {
                              UIApplication.shared.open(url, options: [:], completionHandler: nil)
                          }
                      }
                  }

                  self.bridge?.register(handlerName: "requestNotificationPermission") { (parameters, callback) in
                      let center = UNUserNotificationCenter.current()
                      center.requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in
                          callback?(granted)
                      }
                  }

                  self.bridge?.register(handlerName: "lockOrientation") { (parameters, _) in
                      if let orientation = (parameters as? [String: Any])?["orientation"] as? String {
                          DispatchQueue.main.async {
                              if orientation == "portrait" {
                                  UIDevice.current.setValue(UIInterfaceOrientation.portrait.rawValue, forKey: "orientation")
                              } else if orientation == "landscape" {
                                  UIDevice.current.setValue(UIInterfaceOrientation.landscapeLeft.rawValue, forKey: "orientation")
                              }
                          }
                      }
                  }

                  self.bridge?.register(handlerName: "getBatteryInfo") { (_, callback) in
                      UIDevice.current.isBatteryMonitoringEnabled = true
                      let batteryLevel = UIDevice.current.batteryLevel * 100
                      let batteryState: String
                      switch UIDevice.current.batteryState {
                      case .charging: batteryState = "Charging"
                      case .full: batteryState = "Full"
                      case .unplugged: batteryState = "Unplugged"
                      default: batteryState = "Unknown"
                      }
                      callback?(["batteryLevel": "\(batteryLevel)%", "batteryState": batteryState])
                  }

                  self.bridge?.register(handlerName: "openMaps") { (parameters, _) in
                      guard let address = (parameters as? [String: Any])?["address"] as? String else { return }
                      DispatchQueue.main.async {
                          let urlString = "https://maps.apple.com/?q=\(address)"
                          if let url = URL(string: urlString) {
                              UIApplication.shared.open(url, options: [:], completionHandler: nil)
                          }
                      }
                  }

                  // NEW: Handler to retrieve shared content from the extension
                  self.bridge?.register(handlerName: "getSharedContent") { (_, callback) in
                      if let sharedDefaults = UserDefaults(suiteName: "group.com.example.webkitapp") {
                          let sharedText = sharedDefaults.string(forKey: "sharedText") ?? ""
                          let sharedURL = sharedDefaults.string(forKey: "sharedURL") ?? ""
                          let timestamp = sharedDefaults.double(forKey: "sharedTimestamp")
                          
                          let result: [String: Any] = [
                              "text": sharedText,
                              "url": sharedURL,
                              "timestamp": timestamp,
                              "hasContent": !sharedText.isEmpty || !sharedURL.isEmpty
                          ]
                          
                          // Clear after reading
                          sharedDefaults.removeObject(forKey: "sharedText")
                          sharedDefaults.removeObject(forKey: "sharedURL")
                          sharedDefaults.removeObject(forKey: "sharedTimestamp")
                          sharedDefaults.synchronize()
                          
                          callback?(result)
                      } else {
                          callback?(["text": "", "url": "", "hasContent": false])
                      }
                  }
              }

              func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
                  self.bridge?.call(handlerName: "testJavascriptHandler", data: ["foo": "before ready"], callback: { response in
                      print("JS responded: \(String(describing: response))")
                  })
                  webView.evaluateJavaScript("window._SETTINGS = window._SETTINGS || {}; window._SETTINGS.APPTYPE = 'ios';")
              }

              func webView(_ webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping () -> Void) {
                  let alert = UIAlertController(title: "JS Alert", message: message, preferredStyle: .alert)
                  alert.addAction(UIAlertAction(title: "OK", style: .default) { _ in completionHandler() })
                  present(alert, animated: true)
              }

              func webView(_ webView: WKWebView, runJavaScriptConfirmPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (Bool) -> Void) {
                  let confirmAlert = UIAlertController(title: "JS Confirm", message: message, preferredStyle: .alert)
                  confirmAlert.addAction(UIAlertAction(title: "Cancel", style: .cancel) { _ in
                      completionHandler(false)
                  })
                  confirmAlert.addAction(UIAlertAction(title: "OK", style: .default) { _ in
                      completionHandler(true)
                  })
                  present(confirmAlert, animated: true)
              }

              func webView(_ webView: WKWebView, runJavaScriptTextInputPanelWithPrompt prompt: String, defaultText: String?, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (String?) -> Void) {
                  let promptAlert = UIAlertController(title: "JS Prompt", message: prompt, preferredStyle: .alert)
                  promptAlert.addTextField { textField in
                      textField.text = defaultText
                  }
                  promptAlert.addAction(UIAlertAction(title: "Cancel", style: .cancel) { _ in
                      completionHandler(nil)
                  })
                  promptAlert.addAction(UIAlertAction(title: "OK", style: .default) { _ in
                      let text = promptAlert.textFields?.first?.text
                      completionHandler(text)
                  })
                  present(promptAlert, animated: true)
              }
          }
          EOF

          # 2. Create ActionViewController.swift (Action Extension - more reliable than Share)
          cat <<'EOF' > ActionViewController.swift
          import UIKit
          import MobileCoreServices

          class ActionViewController: UIViewController {
              
              override func viewDidLoad() {
                  super.viewDidLoad()
                  
                  // Set background
                  view.backgroundColor = UIColor(white: 0, alpha: 0.5)
                  
                  // Add loading label
                  let label = UILabel()
                  label.text = "Saving to WebKitApp..."
                  label.textColor = .white
                  label.textAlignment = .center
                  label.translatesAutoresizingMaskIntoConstraints = false
                  view.addSubview(label)
                  
                  NSLayoutConstraint.activate([
                      label.centerXAnchor.constraint(equalTo: view.centerXAnchor),
                      label.centerYAnchor.constraint(equalTo: view.centerYAnchor)
                  ])
                  
                  // Process shared content
                  handleSharedContent()
              }
              
              private func handleSharedContent() {
                  guard let extensionItem = extensionContext?.inputItems.first as? NSExtensionItem else {
                      closeExtension()
                      return
                  }
                  
                  var sharedText = ""
                  var sharedURL = ""
                  let group = DispatchGroup()
                  
                  for attachment in extensionItem.attachments ?? [] {
                      // Plain text
                      if attachment.hasItemConformingToTypeIdentifier("public.plain-text") {
                          group.enter()
                          attachment.loadItem(forTypeIdentifier: "public.plain-text", options: nil) { (item, error) in
                              defer { group.leave() }
                              if let text = item as? String {
                                  sharedText = text
                              } else if let data = item as? Data, let text = String(data: data, encoding: .utf8) {
                                  sharedText = text
                              }
                          }
                      }
                      
                      // URL
                      if attachment.hasItemConformingToTypeIdentifier("public.url") {
                          group.enter()
                          attachment.loadItem(forTypeIdentifier: "public.url", options: nil) { (item, error) in
                              defer { group.leave() }
                              if let url = item as? URL {
                                  sharedURL = url.absoluteString
                              } else if let data = item as? Data, let urlString = String(data: data, encoding: .utf8) {
                                  sharedURL = urlString
                              }
                          }
                      }
                  }
                  
                  group.notify(queue: .main) {
                      print("ðŸ“¤ Sharing - Text: '\(sharedText)', URL: '\(sharedURL)'")
                      self.saveAndOpen(text: sharedText, url: sharedURL)
                  }
              }
              
              private func saveAndOpen(text: String, url: String) {
                  // Save to App Group
                  if let sharedDefaults = UserDefaults(suiteName: "group.com.example.webkitapp") {
                      if !text.isEmpty {
                          sharedDefaults.set(text, forKey: "sharedText")
                          print("âœ… Saved text: \(text)")
                      }
                      if !url.isEmpty {
                          sharedDefaults.set(url, forKey: "sharedURL")
                          print("âœ… Saved URL: \(url)")
                      }
                      sharedDefaults.set(Date().timeIntervalSince1970, forKey: "sharedTimestamp")
                      sharedDefaults.synchronize()
                  }
                  
                  // Open main app
                  if let url = URL(string: "webkitapp://shared") {
                      openURL(url)
                  }
                  
                  // Close extension after delay
                  DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                      self.closeExtension()
                  }
              }
              
              @objc private func openURL(_ url: URL) {
                  var responder: UIResponder? = self
                  let selector = #selector(openURL(_:))
                  
                  while let currentResponder = responder {
                      if currentResponder != self && currentResponder.responds(to: selector) {
                          currentResponder.perform(selector, with: url)
                          return
                      }
                      responder = currentResponder.next
                  }
                  
                  // Fallback: try to use extensionContext
                  extensionContext?.open(url, completionHandler: nil)
              }
              
              private func closeExtension() {
                  extensionContext?.completeRequest(returningItems: [], completionHandler: nil)
              }
          }
          EOF

          # 3. Create Info.plist for main app
          cat <<'EOF' > Info.plist
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>CFBundleExecutable</key>
              <string>$(EXECUTABLE_NAME)</string>
              <key>CFBundleIdentifier</key>
              <string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
              <key>CFBundleName</key>
              <string>$(PRODUCT_NAME)</string>
              <key>CFBundlePackageType</key>
              <string>$(PRODUCT_BUNDLE_PACKAGE_TYPE)</string>
              <key>CFBundleShortVersionString</key>
              <string>1.0</string>
              <key>CFBundleVersion</key>
              <string>1</string>
              <key>LSRequiresIPhoneOS</key>
              <true/>
              <key>UILaunchScreen</key>
              <dict/>
              <key>NSAppTransportSecurity</key>
              <dict>
                  <key>NSAllowsArbitraryLoads</key>
                  <true/>
              </dict>
              <key>UIBackgroundModes</key>
              <array>
                  <string>fetch</string>
                  <string>processing</string>
              </array>
              <key>BGTaskSchedulerPermittedIdentifiers</key>
              <array>
                  <string>com.example.webkitapp.refresh</string>
              </array>
              <key>CFBundleURLTypes</key>
              <array>
                  <dict>
                      <key>CFBundleURLSchemes</key>
                      <array>
                          <string>webkitapp</string>
                      </array>
                      <key>CFBundleURLName</key>
                      <string>com.example.webkitapp</string>
                  </dict>
              </array>
          </dict>
          </plist>
          EOF

          # 4. Create Info.plist for Action Extension
          cat <<'EOF' > ActionExtension-Info.plist
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>CFBundleDisplayName</key>
              <string>Save to App</string>
              <key>CFBundleExecutable</key>
              <string>$(EXECUTABLE_NAME)</string>
              <key>CFBundleIdentifier</key>
              <string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
              <key>CFBundleName</key>
              <string>$(PRODUCT_NAME)</string>
              <key>CFBundlePackageType</key>
              <string>$(PRODUCT_BUNDLE_PACKAGE_TYPE)</string>
              <key>CFBundleShortVersionString</key>
              <string>1.0</string>
              <key>CFBundleVersion</key>
              <string>1</string>
              <key>NSExtension</key>
              <dict>
                  <key>NSExtensionAttributes</key>
                  <dict>
                      <key>NSExtensionActivationRule</key>
                      <string>TRUEPREDICATE</string>
                  </dict>
                  <key>NSExtensionMainStoryboard</key>
                  <string>MainInterface</string>
                  <key>NSExtensionPointIdentifier</key>
                  <string>com.apple.ui-services</string>
              </dict>
          </dict>
          </plist>
          EOF

          # 5. Create MainInterface.storyboard for Action Extension
          cat <<'EOF' > MainInterface.storyboard
          <?xml version="1.0" encoding="UTF-8"?>
          <document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="22505" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="ObA-dk-sSI">
              <device id="retina6_12" orientation="portrait" appearance="light"/>
              <dependencies>
                  <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="22504"/>
                  <capability name="Safe area layout guides" minToolsVersion="9.0"/>
                  <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
              </dependencies>
              <scenes>
                  <scene sceneID="7MM-of-jgj">
                      <objects>
                          <viewController id="ObA-dk-sSI" customClass="ActionViewController" customModule="ActionExtension" customModuleProvider="target" sceneMemberID="viewController">
                              <view key="view" contentMode="scaleToFill" id="zMn-AG-sqS">
                                  <rect key="frame" x="0.0" y="0.0" width="393" height="852"/>
                                  <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                                  <color key="backgroundColor" white="0.0" alpha="0.0" colorSpace="custom" customColorSpace="genericGamma22GrayColorSpace"/>
                                  <viewLayoutGuide key="safeArea" id="VXr-Tz-HHm"/>
                              </view>
                          </viewController>
                          <placeholder placeholderIdentifier="IBFirstResponder" id="X47-rx-isc" userLabel="First Responder" sceneMemberID="firstResponder"/>
                      </objects>
                      <point key="canvasLocation" x="140" y="131"/>
                  </scene>
              </scenes>
          </document>
          EOF

      - name: Create Xcode Project with Action Extension
        run: |
          gem install xcodeproj
          ruby <<'RUBY'
          require 'xcodeproj'
          project = Xcodeproj::Project.new('WebKitApp.xcodeproj')
          
          # Create main app target
          target = project.new_target(:application, 'WebKitApp', :ios, '15.0')
          
          # Add files to main app
          app_delegate = project.new_file('AppDelegate.swift')
          info_plist = project.new_file('Info.plist')
          target.add_file_references([app_delegate])

          # Configure main app target
          target.build_configurations.each do |config|
            config.build_settings['INFOPLIST_FILE'] = 'Info.plist'
            config.build_settings['GENERATE_INFOPLIST_FILE'] = 'NO'
            config.build_settings['PRODUCT_BUNDLE_IDENTIFIER'] = 'com.example.webkitapp'
            config.build_settings['SWIFT_VERSION'] = '5.0'
            config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '15.0'
            config.build_settings['CODE_SIGN_ENTITLEMENTS'] = 'WebKitApp.entitlements'
            config.build_settings['DEVELOPMENT_TEAM'] = ''
          end

          # Create Action Extension target
          action_target = project.new_target(:app_extension, 'ActionExtension', :ios, '15.0')
          
          # Add files to action extension
          action_vc = project.new_file('ActionViewController.swift')
          action_info = project.new_file('ActionExtension-Info.plist')
          action_storyboard = project.new_file('MainInterface.storyboard')
          action_target.add_file_references([action_vc])
          action_target.resources_build_phase.add_file_reference(action_storyboard)

          # Configure action extension target
          action_target.build_configurations.each do |config|
            config.build_settings['INFOPLIST_FILE'] = 'ActionExtension-Info.plist'
            config.build_settings['GENERATE_INFOPLIST_FILE'] = 'NO'
            config.build_settings['PRODUCT_BUNDLE_IDENTIFIER'] = 'com.example.webkitapp.ActionExtension'
            config.build_settings['SWIFT_VERSION'] = '5.0'
            config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '15.0'
            config.build_settings['CODE_SIGN_ENTITLEMENTS'] = 'ActionExtension.entitlements'
            config.build_settings['DEVELOPMENT_TEAM'] = ''
          end

          # Create dependency from main app to action extension
          target.add_dependency(action_target)

          project.recreate_user_schemes
          project.save
          RUBY

      - name: Create Entitlements Files
        run: |
          # Main app entitlements
          cat <<'EOF' > WebKitApp.entitlements
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>com.apple.security.application-groups</key>
              <array>
                  <string>group.com.example.webkitapp</string>
              </array>
          </dict>
          </plist>
          EOF

          # Action extension entitlements
          cat <<'EOF' > ActionExtension.entitlements
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>com.apple.security.application-groups</key>
              <array>
                  <string>group.com.example.webkitapp</string>
              </array>
          </dict>
          </plist>
          EOF

      - name: Create and Install Pods
        run: |
          cat <<'EOF' > Podfile
          platform :ios, '15.0'
          use_frameworks!
          
          target 'WebKitApp' do
            pod 'WKWebViewJavascriptBridge', '~> 1.2.0'
          end

          target 'ActionExtension' do
            # Action extension doesn't need the bridge
          end

          post_install do |installer|
            installer.pods_project.targets.each do |target|
              target.build_configurations.each do |config|
                config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '15.0'
              end
            end
          end
          EOF
          pod install

      - name: Build Archive (Unsigned)
        run: |
          xcodebuild archive \
            -workspace WebKitApp.xcworkspace \
            -scheme WebKitApp \
            -configuration Release \
            -archivePath ./build/WebKitApp.xcarchive \
            CODE_SIGNING_ALLOWED=NO \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGN_IDENTITY="" \
            AD_HOC_CODE_SIGNING_ALLOWED=YES

      - name: Package IPA
        run: |
          mkdir -p Payload
          cp -r ./build/WebKitApp.xcarchive/Products/Applications/*.app ./Payload/
          zip -r WebKitApp-Unsigned.ipa Payload

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: WebKit-WebView-IPA-ActionExtension
          path: WebKitApp-Unsigned.ipa
